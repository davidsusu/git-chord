#!/bin/sh
# shellcheck disable=SC2016,SC2086,SC2154

VERSION='0.1.0-SNAPSHOT'

COMMANDS="$( printf '%s' '
help # Prints help (also works: (`-h`))
version # Prints version of the chord extension (also works: (`-v`))
config get set list # Prints the current chord configuration (use (`--defaults`) to see the defaults)
snapshot # Creates a snapshot of the repository state
apply # Applies a previously saved snapshot to the repository
state # Shows the current state based on the configuration
show # Shows full data of a previously saved snapshot
list # Lists previously saved snapshots
diff # Shows diff between a previously saved snapshot and the current state
delete # Deletes a previously saved snapshot
push # Pushes the default chord branch (or using (`--all`): all chord branches)
pull # Pulls the default chord branch (or using (`--all`): all chord branches)
spec commands options # Gets special information mainly for machine processing
' | tail -n +2 )"

DEFAULT_COMMAND='snapshot'

OPTIONS="$( printf '%s' '
trackers.prefix chord/ # Sets the tracker branch prefix
trackers.name main # Sets the tracker branch name
trackers.remotes.default origin # Sets the default remote name for tracker branches
trackers.remotes.allowautoassociate true # Allows automatic associating of the default remote if necessary
branches.store.enabled true # Enables saving the state of tracked branches
branches.store.regex .* # Sets the regex pattern for saving tracked branches
branches.apply.enabled true # Enables applying the saved state of tracked branches
branches.apply.regex .* # Sets the regex pattern for applying tracked branches
branches.apply.allowremove true # Allows removing branches
branches.apply.allowadd true # Allows adding branches
annotatedtags.store.enabled true # Enables saving the state of tracked annotated tags
annotatedtags.store.regex .* # Sets the regex pattern for saving tracked annotated tags
annotatedtags.apply.enabled true # Enables applying the saved state of tracked annotated tags
annotatedtags.apply.regex .* # Sets the regex pattern for applying tracked annotated tags
annotatedtags.apply.allowremove true # Allows removing annotated tags
lightweighttags.store.enabled false # Enables saving the state of tracked lightweight tags
lightweighttags.store.regex .* # Sets the regex pattern for saving tracked lightweight tags
lightweighttags.apply.enabled false # Enables applying the saved state of tracked lightweight tags
lightweighttags.apply.regex .* # Sets the regex pattern for applying tracked lightweight tags
lightweighttags.apply.allowremove false # Allows removing lightweight tags
head.store.enabled true # Enables saving the state of the HEAD
head.apply.enabled true # Allows moving the HEAD
head.apply.sticktocommit false # Sticks to the commit, switches to detached head if necessary
stagingarea.followhead true # Make the staging area following HEAD by default
stagingarea.store.enabled false # Enables saving the state of the staging area
stagingarea.apply.enabled false # Enables applying the saved state of the staging area
workingtree.followstagingarea true # Make the working tree following the staging area by default
workingtree.store.enabled false # Enables saving the state of the working tree
workingtree.apply.enabled false # Enables applying the saved state of the working tree
dryrun false # Enables dry-run mode, no modification will be applied
verbose false # Enables verbose mode, more information will be printed
color true # Enables color mode, ANSI escapes will be used in the output
markdown false # Enables markdown mode, output will be formatted as a markdown document
defaults false # Enables default mode, the default configuration will be used and printed (forcefully)
all false # Enables the operation for all related objects
' | tail -n +2 )"

STATE_FILE='state.yaml'

NL="
"


## string manipulation functions ##

checkStartsWith() { # $1: contextString, $2: prefixToCheck
    case "$1" in
        "$2"*) return 0 ;;
        *) return 1 ;;
    esac
}

checkHasPrefix() { # stdin, $1: prefixToCheck
    while IFS= read -r line; do
        if checkStartsWith "$line" "$1"; then
            return 0
        fi
    done
    return 1
}

appendLine() { # $1: array, $2:newLineOrLines
    if [ -z "$1" ]; then
        printf '%s\n' "$2"
    elif [ "$( printf '%s' "$1" )" = "$1" ]; then
        printf '%s\n%s\n' "$1" "$2"
    else
        printf '%s%s\n' "$1" "$2"
    fi
}

getNthLine() { # $1: lines, $2 lineNo
    printf '%s\n' "$1" | sed "${2}q;d"
}

repeatChar() { # $1: char, $2: length
    printf "%${2}s" | tr ' ' "$1"
}

normalizeKey() { # $1: rawKey
    printf '%s\n' "$1" | sed -E 's/^\-\-(no\-)?//i' | tr '-' '.' | tr '[:upper:]' '[:lower:]'
}

escapeValue() { # $1: value
    printf '%s\n' "$1" | sed "s/'/'\\\\''/g"
}

checkBoolValue() { # $1: valueToCheck
    if [ "$1" = 'true' ] || [ "$1" = 'false' ]; then
        return 0
    else 
        return 1
    fi
}

isBoolValue() { # $1: valueToCheck
    if checkBoolValue "$1"; then
        echo '1'
    else 
        echo ''
    fi
}

checkTruthy() { # $1: valueToCheck
    case "$1" in
        true|on|yes|1) return 0 ;;
        *) return 1 ;;
    esac
}


## miscellaneous functions ##

printNlIf() { # $1: isVerbose
    if checkTruthy "$1"; then
        echo ''
    fi
}

deduplicateLinesStable() ( # stdin
    output=''
    while IFS= read -r line; do
        if ! printf '%s' "$output" | grep -Fxq "$line"; then
            output="${output}${line}${NL}"
        fi
    done
    printf '%s' "$output"
)

checkMapKey() ( # $1: map, $2: key
    while IFS= read -r line; do
        if checkStartsWith "$line" "${2} "; then
            return 0
        fi
    done <<EOF
$( printf '%s\n' "$1" )
EOF
    return 1
)

getMapValue() ( # $1: map, $2: key
    printf '%s\n' "$1" | while IFS= read -r line; do
        if checkStartsWith "$line" "${2} "; then
            printf '%s\n' "$line" | cut -d ' ' -s -f 2-
            break
        fi
    done
)

setMapValue() ( # $1: map, $2: key, $3: newValue
    found=''
    while IFS= read -r line; do
        if checkStartsWith "$line" "${2} "; then
            printf '%s %s\n' "$2" "$3"
            found='1'
        elif [ -n "$line" ]; then
            printf '%s\n' "$line"
        fi
    done <<EOF
$( printf '%s\n' "$1" )
EOF
    if [ -z "$found" ]; then
        printf '%s %s\n' "$2" "$3"
    fi
)

requireMapKey() ( # $1: map, $2: key, $3: newValue
    found=''
    while IFS= read -r line; do
        if [ -n "$line" ]; then
            printf '%s\n' "$line"
            if checkStartsWith "$line" "${2} "; then
                found='1'
            fi
        fi
    done <<EOF
$( printf '%s\n' "$1" )
EOF
    if [ -z "$found" ]; then
        printf '%s %s\n' "$2" "$3"
    fi
)

mergeMaps() { # $1: table1, $2: table2
    {
        printf '%s' "$1" | sed -E 's/([^ ]*) /\1 1 /'
        printf '%s' "$2" | sed -E 's/([^ ]*) /\1 2 /'
    } | sort | (
        pendingKey=''
        pendingValue=''
        while IFS=' ' read -r key src value; do
            if [ -n "$key" ]; then
                if [ "$src" = '1' ]; then
                    if [ -n "$pendingKey" ]; then
                        printf "%s 1 %s\n" "$pendingKey" "$pendingValue"
                    fi
                    pendingKey="$key"
                    pendingValue="$value"
                else
                    if [ -n "$pendingKey" ]; then
                        if [ "$key" = "$pendingKey" ]; then
                            printf "%s * %s %s\n" "$key" "$pendingValue" "$value"
                        else
                            printf "%s 1 %s\n" "$pendingKey" "$pendingValue"
                            printf "%s 2 %s\n" "$key" "$value"
                        fi
                    else
                        printf "%s 2 %s\n" "$key" "$value"
                    fi
                    pendingKey=''
                    pendingValue=''
                fi
            fi
        done;
        if [ -n "$pendingKey" ]; then
            printf "%s 1 %s\n" "$pendingKey" "$pendingValue"
        fi
    )
}

normalizeSystemErrorMessage() { # stdin
    sed -E 's/^error:\s*//i; s/^\/[^:]+:\s+[0-9]+:\s+//'
}

catchSystemErrorMessage() ( # $@: command with arguments
    errorMessage="$( "$@" 2>&1 >/dev/null )"
    statusCode="$?"
    if [ "$statusCode" -eq 0 ]; then
        return 0
    else
        printf '%s\n' "$errorMessage" | normalizeSystemErrorMessage
        return "$statusCode"
    fi
)


## argument functions ##

getArgumentKey() { # $1: arg
    normalizeKey "$( printf '%s\n' "$1" | cut -d '=' -f 1 | sed -E 's/\-\-(no\-)?//i' )"
}

getArgumentValue() ( # $1: arg, $2: isBool
    candidate="$( printf '%s\n' "$1" | cut -d '=' -s -f 2- )"
    if [ -z "$candidate" ] && [ -n "$2" ]; then
        if checkStartsWith "$1" '--no-'; then
            echo 'false'
        else
            echo 'true'
        fi
    else
        printf '%s\n' "$candidate"
    fi
)

isArgumentNextExpected() { # $1: arg, $2: isBool
    if [ -n "$2" ]; then
        echo ''
    else
        case "$1" in
            *=*) echo '' ;;
            *) echo '1' ;;
        esac
    fi
}


## YAML functions ##

extractYamlSubLines() ( # stdin, $1: keyLinePrefix
    found=''
    while IFS= read -r line; do
        if [ -n "$found" ]; then
            if printf '%s\n' "$line" | grep -qE '^    '; then
                printf '%s\n' "$line" | sed -E 's/^    //'
            elif [ -n "$line" ]; then
                break
            fi
        elif checkStartsWith "$line" "$1"; then
            found='1'
        fi
    done
)

quoteYamlValue() { # stdin
    printf "'%s'\n" "$( sed -E "s/'/''/" )"
}

unquoteYamlValue() { # stdin
    sed -E "s/^'//; s/'$//; s/''/'/g"
}

extractYamlValue() ( # stdin, $1: keyLinePrefix
    found=''
    while IFS= read -r line; do
        if [ -n "$found" ]; then
            if printf '%s\n' "$line" | grep -qE '^    '; then
                printf '%s\n' "$line" | sed -E 's/^    //'
            else
                break
            fi
        elif checkStartsWith "$line" "$1"; then
            afterString="$( printf '%s\n' "$line" | sed -E 's/^.{'"$( printf '%s' "$1" | wc -m )}\\s*//; s/\\s*$//" )"
            if [ "$afterString" = '|+' ]; then
                found='1'
            elif [ -n "$afterString" ]; then
                printf '%s\n' "$afterString" | unquoteYamlValue
                break
            else
                echo ''
                break
            fi
        fi
    done
)

getYamlKeyPrefixes() { # stdin
    grep -Eo "^([^': ]+|'([^']|'')*'):" 
}

extractYamlKey() { # stdin
    sed -E 's/:$//' | unquoteYamlValue
}

reformatYamlKeyValueLines() ( # stdin, $1: outSeparator
    while IFS= read -r line; do
        keyPrefix="$( printf '%s\n' "$line" | getYamlKeyPrefixes )"
        key="$( printf '%s\n' "$keyPrefix" | extractYamlKey )"
        afterString="$( printf '%s\n' "$line" | sed -E 's/^.{'"$( printf '%s' "$keyPrefix" | wc -m )}\\s*//; s/\\s*$//" )"
        value="$( printf '%s\n' "$afterString" | unquoteYamlValue )"
        printf '%s%s%s\n' "$key" "$1" "$value"
    done
)

catYamlLinesOrElse() { # stdin, $1: fallbackString
    awk --assign fallback="$1" '{ printf "\n%s",$0 } END { if (NR == 0) { print fallback } else { print "" } }'
}

quoteYamlValuePossiblyMultiline() { # $1: value, $2: indentLength
    # in case of multiline content, YAML appends a trailing newline
    # which is unavoidable and must be considered during reading
    if [ "$( printf '%s' "$1" | wc -l )" -eq 0 ]; then
        printf '%s\n' "$( printf '%s\n' "$1" | quoteYamlValue )"
    else
        printf '|+\n'
        printf '%s\n' "$1" | while IFS= read -r line; do
            printf "%-${2}s%s\\n" '' "$line"
        done
    fi
}


defaults=$( printf '%s' "$OPTIONS" | sed -E 's/ #[^#]*//' )
config="$defaults"

while IFS= read -r line; do
    givenKey="$( printf '%s\n' "$line" | cut -d ' ' -f 1 | sed -E 's/^chord\.//' )"
    if [ -z "$givenKey" ]; then
        continue
    fi
    if checkMapKey "$defaults" "$givenKey"; then
        givenValue="$( printf '%s\n' "$line" | cut -d ' ' -s -f 2- )"
        config="$( setMapValue "$config" "$givenKey" "$givenValue" )"
    else
        printf 'WARNING: %s: %s\n' 'Unrecognized configuration key' "$givenKey" >&2
    fi
done <<EOF
$( git config --get-regexp 'chord\..*' )
EOF

afterDoubleDash=''
previousKey=''
command=''
nonOptArgs=''
while [ "$#" -gt 0 ]; do
    arg="$1"
    shift
    if [ -n "$previousKey" ]; then
        config="$( setMapValue "$config" "$previousKey" "$arg" )"
        previousKey=''
        continue
    fi
    if ! checkStartsWith "$arg" '--' || [ -n "$afterDoubleDash" ]; then
        if [ -z "$command" ]; then
            command="$arg"
        else
            nonOptArgs="$( appendLine "$nonOptArgs" "$arg" )"
        fi
        continue
    elif [ "$arg" = '--' ]; then
        afterDoubleDash='1'
        continue
    fi
    argKey="$( getArgumentKey "$arg" )"
    if ! checkMapKey "$defaults" "$argKey"; then
        printf 'ERROR: %s: %s\n' 'Unrecognized configuration key' "$argKey" >&2
        exit 1
    fi
    argDefaultValue="$( getMapValue "$defaults" "$argKey" )"
    argIsBool="$( isBoolValue "$argDefaultValue" )"
    argValue="$( getArgumentValue "$arg" "$argIsBool" )"
    argHasNext="$( isArgumentNextExpected "$arg" "$argIsBool" )"
    if [ -n "$argHasNext" ]; then
        previousKey="$argKey"
    else
        config="$( setMapValue "$config" "$argKey" "$argValue" )"
    fi
done
if [ -n "$previousKey" ]; then
    printf 'No value argument given for configuration key: %s\n' "$previousKey" >&2
    exit 1
fi
if [ -z "$command" ]; then
    command="$DEFAULT_COMMAND"
fi

subcommand="$( getNthLine "$nonOptArgs" 1 )"

while IFS= read -r configLine; do
    configValue="$( printf '%s\n' "$configLine" | cut -d ' ' -f 2- )"
    outVariableName="configValue_$( printf '%s\n' "$configLine" | cut -d ' ' -f 1 | tr '.' '_' )"
    eval "${outVariableName}='$( escapeValue "$configValue")'"
done <<EOF
$( printf '%s\n' "$config" )
EOF

formatError=''
formatErrorEnd=''
formatWarning=''
formatWarningEnd=''
formatSuccess=''
formatSuccessEnd=''
formatInfo=''
formatInfoEnd=''
formatRemove=''
formatRemoveEnd=''
formatAdd=''
formatAddEnd=''
formatBold=''
formatBoldEnd=''
formatItalic=''
formatItalicEnd=''
formatCode=''
formatCodeEnd=''
if checkTruthy "$configValue_color"; then
    if checkTruthy "$configValue_markdown"; then
        formatError='**'
        formatErrorEnd='**'
        formatWarning=''
        formatWarningEnd=''
        formatSuccess=''
        formatSuccessEnd=''
        formatInfo=''
        formatInfoEnd=''
        formatRemove=''
        formatRemoveEnd=''
        formatAdd=''
        formatAddEnd=''
        formatBold='**'
        formatBoldEnd='**'
        formatItalic='*'
        formatItalicEnd='*'
        formatCode='`'
        formatCodeEnd='`'
    else
        formatError="$( printf '\e[1;31m' )"
        formatErrorEnd="$( printf '\e[0m' )"
        formatWarning="$( printf '\e[1;33m' )"
        formatWarningEnd="$( printf '\e[0m' )"
        formatSuccess="$( printf '\e[1;32m' )"
        formatSuccessEnd="$( printf '\e[0m' )"
        formatInfo="$( printf '\e[1;96m' )"
        formatInfoEnd="$( printf '\e[0m' )"
        formatRemove="$( printf '\e[1;31m' )"
        formatRemoveEnd="$( printf '\e[0m' )"
        formatAdd="$( printf '\e[1;32m' )"
        formatAddEnd="$( printf '\e[0m' )"
        formatBold="$( printf '\e[1m' )"
        formatBoldEnd="$( printf '\e[0m' )"
        formatItalic="$( printf '\e[1;33m' )"
        formatItalicEnd="$( printf '\e[0m' )"
        formatCode="$( printf '\e[1m' )"
        formatCodeEnd="$( printf '\e[0m' )"
    fi
fi

getLength() { # $1: string
    if checkTruthy "$configValue_color"; then
        printf '%s' "$1" | sed -E 's/\x1b\[[0-9;]*m//g' | wc -m
    else
        printf '%s' "$1" | wc -m
    fi
}

padLeft() { # $1: string, $2: length
    if checkTruthy "$configValue_color"; then
        (
            printf '%s' "$1"
            fieldLength="$2"
            stringLength="$( getLength "$1" )"
            padLength=$(( fieldLength - stringLength ))
            if [ "$padLength" -gt 0 ]; then
                repeatChar ' ' "$padLength"
            fi
        )
    else
        printf "%-${2}s" "$1"
    fi
}

applyInlineFormatting() { # stdin
    sed -E "s/\(\*\*/${formatBold}/g; s/\*\*\)/${formatBoldEnd}/g; s/\(\*/${formatItalic}/g; s/\*\)/${formatItalicEnd}/g; s/\(\`/${formatCode}/g; s/\`\)/${formatCodeEnd}/g"
}

removeInlineFormatting() { # stdin
    sed -E "s/\(\*\*?|\*\*?\)|\(\`|\`\)//g"
}

escapeHtml() { # stdin
    sed -E 's/&/\&amp;/g; s/"/\&quot;/g; s/</\&lt;/g; s/>/\&gt;/g'
}

escapeMarkdown() ( # stdin
    inCodeBlock=0
    sed -E 's/$/\n/; s/`/\n/g' | while IFS= read -r token; do
        inCodeBlock=$(( 1 - inCodeBlock ))
        if [ "$inCodeBlock" -eq 1 ]; then
            printf '%s' "$token" | escapeHtml
        elif [ -n "$token" ]; then
            printf '`%s`' "$token"
        else
            echo ''
        fi
    done
)

printLogMessage() { # $1: message
    if checkTruthy "$configValue_markdown"; then
        printf -- '- %s\n' "$1"
    else
        printf '%s\n' "$1"
    fi
}

logInfoMessage() { # $1: message
    if checkTruthy "$configValue_verbose"; then
        printLogMessage "${formatInfo}INFO: ${1}${formatInfoEnd}"
    fi
}

logWarningMessage() { # $1: message
    printLogMessage "${formatWarning}WARNING: ${1}${formatWarningEnd}"
}

printGrandTitle() { # $1: title
    if checkTruthy "$configValue_markdown"; then
        printf '# %s\n\n' "$1" | applyInlineFormatting | escapeMarkdown
    else
        echo ''
        printf '%s%s%s\n' "$formatBold" "$1" "$formatBoldEnd" | removeInlineFormatting
        printf '%s\n\n' "$( repeatChar '=' "$( getLength "$1" )" )"
        printNlIf "$configValue_verbose"
    fi
}

printTitle() { # $1: title
    if checkTruthy "$configValue_markdown"; then
        printf '# %s\n\n' "$1" | applyInlineFormatting | escapeMarkdown
    else
        printNlIf "$configValue_verbose"
        printf '%s%s%s\n\n' "$formatBold" "$1" "$formatBoldEnd" | removeInlineFormatting
    fi
}

printSubtitle() { # $1: subtitle
    if checkTruthy "$configValue_markdown"; then
        printf '## %s\n\n' "$1" | applyInlineFormatting | escapeMarkdown
    else
        printNlIf "$configValue_verbose"
        printf '%s%s%s\n' "$formatBold" "$1" "$formatBoldEnd" | removeInlineFormatting
        printNlIf "$configValue_verbose"
    fi
}

printParagraph() { # $@: content
    ( printf '%s ' "$@" ; echo '' ) | sed -E 's/ $//' |
        applyInlineFormatting |
        if checkTruthy "$configValue_markdown"; then
            escapeMarkdown | fold -w 80 -s
        else
            fold -w 80 -s | sed -E 's/^/  /'
        fi
    echo ''
}

printList() { # $@: items
    while [ "$#" -gt '0' ]; do
        if checkTruthy "$configValue_markdown"; then
            printf -- '- %s\n' "$( printf '%s\n' "$1" | sed -E 's/^/  /' )" | sed -E 's/^\-   /- /'
        else
            printf '   %s*%s %s\n' "$formatBold" "$formatBoldEnd" "$( printf '%s\n' "$1" | sed  -E 's/^/     /' )" | sed -E 's/^(   \S+ )     /\1/'
        fi
        shift
    done
    echo ''
}

printListStdin() ( # stdin
    while IFS= read -r line; do
        if checkTruthy "$configValue_markdown"; then
            printf -- '- %s\n' "$line"
        else
            printf '   %s*%s %s\n' "$formatBold" "$formatBoldEnd" "$line"
        fi
    done
    echo ''
)

printCodeBlock() { # $@: content
    if checkTruthy "$configValue_markdown"; then
        printf '```\n'
        printf '%s\n' "$@"
        printf '```\n\n'
    else
        printf '%s\n' "$@" | sed -E 's/^/  /'
        echo ''
    fi
}

printTableTitle() { # $@: title-width pairs
    if checkTruthy "$configValue_markdown"; then
        while [ "$#" -gt '1' ]; do
            printf '| %s ' "$1" | escapeMarkdown
            shift; shift
        done
        echo '|'
    else
        printf ' '
        while [ "$#" -gt '1' ]; do
            printf ' %s%s%s' "$formatBold" "$( padLeft "$1" "$2" )" "$formatBoldEnd"
            shift; shift
        done
        echo ''
    fi
}

printTableSeparator() { # $@: widths
    if checkTruthy "$configValue_markdown"; then
        while [ "$#" -gt '0' ]; do
            printf '| --- '
            shift
        done
        echo '|'
    else
        printf ' '
        while [ "$#" -gt '0' ]; do
            printf ' %s%s%s' "$formatBold" "$( repeatChar '=' "$1" )" "$formatBoldEnd"
            shift
        done
        echo ''
    fi
}

printTableRow() { # $@: value-width pairs
    if checkTruthy "$configValue_markdown"; then
        while [ "$#" -gt '1' ]; do
            printf '| %s ' "$1" | escapeMarkdown
            shift; shift
        done
        echo '|'
    else
        printf ' '
        while [ "$#" -gt '1' ]; do
            printf ' %s' "$( padLeft "$1" "$2" )"
            shift; shift
        done
        echo ''
    fi
}

printCommandShortDescription() { # $1: commandName, $2: commandDescription
    if checkTruthy "$configValue_markdown"; then
        printf '`%s`: %s.\n\n' "$1" "$( printf '%s\n' "$2" | applyInlineFormatting )"
    else
        printf '  %s%s%s\n' "$formatBold" "$1" "$formatBoldEnd"
        printf '    %s\n' "$2" | applyInlineFormatting
        echo ''
    fi
}

printOptionShortDescription() { # $1: optionName, $2: defaultValue, $3: optionDescription
    if checkTruthy "$configValue_markdown"; then
        printf '`%s`: %s. Default: `%s`\n\n' \
            "$1" "$( printf '%s\n' "$3" | applyInlineFormatting )" "$2"
    else
        if checkTruthy "$configValue_verbose"; then
            printf '  %s%s%s%sBuilt-in default: %s%s\n      %s\n\n' \
                "$formatBold" "$( padLeft "$1" 41 )" "$formatBoldEnd" \
                "$formatInfo" "$2" "$formatBoldEnd" \
                "$( printf '%s\n' "$3" | applyInlineFormatting )"
        else
            printf '  %s%s%s\n      %s\n\n' \
                "$formatBold" "$( padLeft "$1" 41 )" "$formatBoldEnd" \
                "$( printf '%s\n' "$3" | applyInlineFormatting )"
        fi
    fi
}

getHeadReference() {
    git symbolic-ref --short HEAD 2>/dev/null
}

getHeadCommitId() {
    git rev-parse --revs-only HEAD 2>/dev/null
}

getHeadPointingTo() {
    reference="$( getHeadReference )"
    if [ -n "$reference" ]; then
        printf '%s\n' "$reference"
    else
        getHeadCommitId
    fi
}

getWorkingTreeTreeId() {
    stagingAreaTreeId="$( git write-tree )"
    git add --all
    git write-tree
    git read-tree "$stagingAreaTreeId"
}

applyWorkingTreeTreeId() { # $1: newTreeId
    stagingAreaTreeId="$( git write-tree )"
    headReference="$( getHeadReference )"
    headCommitId="$( getHeadCommitId )"
    commitId="$( git commit-tree "$1" -m "Working tree state to apply" )"
    { git stash push --include-untracked -q -m "Working tree state backup" && git stash apply -q ; } || return 1
    { git reset --hard && git checkout "$commitId" ; } || exit 1
    if [ -n "$headReference" ]; then
        git symbolic-ref HEAD refs/heads/"$headReference" || return 1
    else
        git update-ref HEAD "$headCommitId" || return 1
    fi
    git read-tree "$stagingAreaTreeId" || return 1
    return 0
}

printMatchingBranches() { # $1: $regex
    git for-each-ref --format='%(refname:short) %(objectname)' refs/heads |
        awk --assign search="$configValue_trackers_prefix" 'substr($0, 1, length(search)) != search { print }' |
        grep -E "^${1} "
}

printMatchingAnnotatedTags() { # $1: $regex
    git for-each-ref refs/tags |
        grep -E '\w+ tag\s+refs/tags/'"$1"'$' |
        sed -E 's/^([^ ]+) tag\trefs\/tags\/([^ ]+)$/\2 \1/'
}

printMatchingLightWeightTags() {  # $1: $regex
    git for-each-ref refs/tags |
        grep -E '\w+ commit\s+refs/tags/'"$1"'$' |
        sed -E 's/^([^ ]+) commit\trefs\/tags\/([^ ]+)$/\2 \1/'
}

printState() {
    # stdin is holded back until all possible stderr was printed
    printf '%s\n' "$(
        printf 'timestamp: %s\n' "$( date --utc +'%Y-%m-%dT%H:%M:%SZ' | quoteYamlValue )"
        if checkTruthy "$configValue_branches_store_enabled"; then
            printf 'branches:'
            printMatchingBranches "$configValue_branches_store_regex" |
                while IFS=' ' read -r branchName commitId; do
                    printf '    %s: %s\n' "$( printf '%s\n' "$branchName" | quoteYamlValue )" "$( printf '%s\n' "$commitId" | quoteYamlValue )"
                done |
                catYamlLinesOrElse ' {}'
        fi
        if checkTruthy "$configValue_annotatedtags_store_enabled"; then
            printf 'annotatedTags:'
            printMatchingAnnotatedTags "$configValue_annotatedtags_store_regex" |
                while IFS=' ' read -r annotatedTagName tagId; do
                    printf '    %s:\n' "$( printf '%s\n' "$annotatedTagName" | quoteYamlValue )"
                    printf '        tagId: %s\n' "$( printf '%s\n' "$tagId" | quoteYamlValue )"
                    printf '        commitId: %s\n' "$( git rev-parse "$tagId"'^{commit}' | quoteYamlValue )"
                    printf '        message: %s\n' "$( quoteYamlValuePossiblyMultiline "$( git tag --list "$annotatedTagName" -n99 --format='%(contents)' | head -n -1 )" 12 )"
                done |
                catYamlLinesOrElse ' {}'
        fi
        if checkTruthy "$configValue_lightweighttags_store_enabled"; then
            printf 'lightWeightTags:'
            printMatchingLightWeightTags "$configValue_lightweighttags_store_regex" |
                while IFS=' ' read -r lightweightTagName commitId; do
                    printf '    %s: %s\n' "$( printf '%s\n' "$lightweightTagName" | quoteYamlValue )" "$commitId"
                done |
                catYamlLinesOrElse ' {}'
        fi
        if checkTruthy "$configValue_head_store_enabled"; then
            printf 'head:\n'
            printf '    pointingTo: %s\n' "$( getHeadPointingTo | quoteYamlValue )"
            printf '    ref: %s\n' "$( getHeadReference | quoteYamlValue )"
            printf '    commitId: %s\n' "$( getHeadCommitId | quoteYamlValue )"
        fi
        if checkTruthy "$configValue_stagingarea_store_enabled"; then
            printf 'stagingArea:\n'
            printf '    treeId: %s\n' "$( git write-tree | quoteYamlValue )"
        fi
        if checkTruthy "$configValue_workingtree_store_enabled"; then
            printf 'workingTree:\n'
            printf '    treeId: %s\n' "$( getWorkingTreeTreeId | quoteYamlValue )"
        fi
    )"
}

printRefMessagesByMergedTable() { # $1: mergedTable, $2: entityName, $3: sectionName
    if [ -z "$( printf '%s' "$1" )" ]; then
        if checkTruthy "$configValue_all"; then
            printf '%s\n' "${formatInfo}${3} section stayed empty${formatInfoEnd}"
        fi
        return
    fi
    while IFS=' ' read -r branchName src value; do if [ -n "$branchName" ]; then
        printf '%s\n' "${formatRemove}${2} removed:${formatRemoveEnd} ${formatCode}${branchName}${formatCodeEnd}"
    fi done <<EOF
$( printf '%s' "$1" | grep -E '^[^ ]* 1' )
EOF
    while IFS=' ' read -r branchName src value; do if [ -n "$branchName" ]; then
        printf '%s\n' "${formatAdd}${2} added:${formatAddEnd} ${formatCode}${branchName}${formatCodeEnd}, pointing to ${formatCode}${value}${formatCodeEnd}"
    fi done <<EOF
$( printf '%s' "$1" | grep -E '^[^ ]* 2' )
EOF
    while IFS=' ' read -r branchName src value1 value2; do if [ -n "$branchName" ]; then
        if [ "$value1" != "$value2" ]; then
            printf '%s\n' "${formatInfo}${2} changed:${formatInfoEnd} ${formatCode}${branchName}${formatCodeEnd}, from ${formatCode}${value1}${formatCodeEnd} to ${formatCode}${value2}${formatCodeEnd}"
        elif checkTruthy "$configValue_all"; then
            printf '%s\n' "${formatInfo}${2} stayed:${formatInfoEnd} ${formatCode}${branchName}${formatCodeEnd}, at ${formatCode}${value1}${formatCodeEnd}"
        fi
    fi done <<EOF
$( printf '%s' "$1" | grep -E '^[^ ]* \*' )
EOF
}

extractSimpleRefKeyValues() { # $1: stateYaml
    printf '%s\n' "$1" | grep -E '.' | reformatYamlKeyValueLines ' '
}

extractAnnotatedTagRefKeyValues() ( # $1: stateYaml
    while IFS= read -r keyPrefix; do
        if [ -n "$keyPrefix" ]; then
            key="$( printf '%s\n' "$keyPrefix" | extractYamlKey )"
            value="$( printf '%s' "$1" | extractYamlSubLines "$keyPrefix" | extractYamlValue 'tagId:' )"
            printf '%s %s\n' "$key" "$value"
        fi
    done <<EOF
$( printf '%s\n' "$1" | getYamlKeyPrefixes )
EOF
)

printRefVerboseDiff() ( # $1: stateYaml1, $2: stateYaml2, $3: keyPrefix, $4: entityName, $5: sectionName, $6: reformatFunctionName
    stateYaml1="$1"
    stateYaml2="$2"
    keyPrefix="$3"
    entityName="$4"
    sectionName="$5"
    reformatFunctionName="$6"

    messageLines=''
    if printf '%s\n' "$stateYaml1" | checkHasPrefix "$keyPrefix"; then
        if printf '%s\n' "$stateYaml2" | checkHasPrefix "$keyPrefix"; then
            table1="$( "$reformatFunctionName" "$( printf '%s\n' "$stateYaml1" | extractYamlSubLines "$keyPrefix" )${NL}" )${NL}"
            table2="$( "$reformatFunctionName" "$( printf '%s\n' "$stateYaml2" | extractYamlSubLines "$keyPrefix" )${NL}" )${NL}"
            mergedTable="$( mergeMaps "$table1" "$table2" )${NL}"
            itemMessages="$( printRefMessagesByMergedTable "$mergedTable" "$entityName" "$sectionName" )"
            if [ -n "$itemMessages" ]; then
                messageLines="${messageLines}${itemMessages}${NL}"
            fi
        else
            messageLines="${messageLines}${formatWarning}${sectionName} section removed${formatWarningEnd}${NL}"
        fi
    else
        if printf '%s\n' "$stateYaml2" | checkHasPrefix "$keyPrefix"; then
            messageLines="${messageLines}${formatWarning}${sectionName} section added${formatWarningEnd}${NL}"
            while IFS=' ' read -r refName commitId; do
                messageLines="${messageLines}${formatAdd}${entityName} added${formatAddEnd}: ${formatCode}${refName}${formatCodeEnd}, pointing to ${formatCode}${commitId}${formatCodeEnd}${NL}"
            done <<EOF
    $( printf '%s\n' "$stateYaml2" | extractYamlSubLines "$keyPrefix" | reformatYamlKeyValueLines ' ' )
EOF
        fi
    fi
    if [ -n "$messageLines" ]; then
        printSubtitle "$sectionName"
        printf '%s' "$messageLines" | printListStdin
    fi
)

getHeadStateString() { # $1: ref, $2: commitId
    if [ -n "$1" ]; then
        printf '%s' "$1"
    else
        printf 'detached head'
    fi
    printf ' (%s)' "$2"
}

extractHeadStateString() { # $1: stateYaml
    getHeadStateString \
        "$( printf '%s\n' "$1" | extractYamlSubLines "head:" | extractYamlValue 'ref:' )" \
        "$( printf '%s\n' "$1" | extractYamlSubLines "head:" | extractYamlValue 'commitId:' )" \
    ;
}

printHeadVerboseDiff() ( # $1: stateYaml1, $2: stateYaml2
    stateYaml1="$1"
    stateYaml2="$2"

    messageLines=''
    if printf '%s\n' "$stateYaml1" | checkHasPrefix "head:"; then
        if printf '%s\n' "$stateYaml2" | checkHasPrefix "head:"; then
            headStateString1="$( extractHeadStateString "$stateYaml1" )"
            headStateString2="$( extractHeadStateString "$stateYaml2" )"
            if [ "$headStateString1" != "$headStateString2" ]; then
                messageLines="${messageLines}${formatInfo}HEAD changed${formatInfoEnd}, from ${formatCode}${headStateString1}${formatCodeEnd} to ${formatCode}${headStateString2}${formatCodeEnd}${NL}"
            elif checkTruthy "$configValue_all"; then
                messageLines="${messageLines}${formatInfo}HEAD stayed${formatInfoEnd}, at ${formatCode}${headStateString1}${formatCodeEnd}${NL}"
            fi
        else
            messageLines="${messageLines}${formatWarning}HEAD section removed${formatWarningEnd}${NL}"
        fi
    else
        if printf '%s\n' "$stateYaml2" | checkHasPrefix "head:"; then
            headStateString2="$( extractHeadStateString "$stateYaml2" )"
            messageLines="${messageLines}${formatWarning}HEAD section added${formatWarningEnd}, pointing to ${formatCode}${headStateString2}${formatCodeEnd}${NL}"
        fi
    fi
    if [ -n "$messageLines" ]; then
        printSubtitle "HEAD"
        printf '%s' "$messageLines" | printListStdin
    fi
)

printTreeVerboseDiff() ( # $1: stateYaml1, $2: stateYaml2, $3: keyPrefix, $4: sectionName
    stateYaml1="$1"
    stateYaml2="$2"
    keyPrefix="$3"
    sectionName="$4"
    
    messageLines=''
    if printf '%s\n' "$stateYaml1" | checkHasPrefix "$keyPrefix"; then
        if printf '%s\n' "$stateYaml2" | checkHasPrefix "$keyPrefix"; then
            treeId1="$( printf '%s\n' "$stateYaml1" | extractYamlSubLines "$keyPrefix" | extractYamlValue 'treeId:' )"
            treeId2="$( printf '%s\n' "$stateYaml2" | extractYamlSubLines "$keyPrefix" | extractYamlValue 'treeId:' )"
            if [ "$treeId1" != "$treeId2" ]; then
                messageLines="${messageLines}${formatInfo}${sectionName} changed${formatInfoEnd}, from tree ${formatCode}${treeId1}${formatCodeEnd} to tree ${formatCode}${treeId2}${formatCodeEnd}${NL}"
            elif checkTruthy "$configValue_all"; then
                messageLines="${messageLines}${formatInfo}${sectionName} stayed${formatInfoEnd}, at tree ${formatCode}${treeId1}${formatCodeEnd}${NL}"
            fi
        else
            messageLines="${messageLines}${formatWarning}${sectionName} section removed${formatWarningEnd}${NL}"
        fi
    else
        if printf '%s\n' "$stateYaml2" | checkHasPrefix "$keyPrefix"; then
            treeId2="$( printf '%s\n' "$stateYaml2" | extractYamlSubLines "$keyPrefix" | extractYamlValue 'treeId:' )"
            messageLines="${messageLines}${formatWarning}${sectionName} section added${formatWarningEnd}, pointing to tree ${formatCode}${treeId2}${formatCodeEnd}${NL}"
        fi
    fi
    if [ -n "$messageLines" ]; then
        printSubtitle "$sectionName"
        printf '%s' "$messageLines" | printListStdin
    fi
)

printAllTrackerBranches() {
    git for-each-ref --format='%(refname:short)' refs/heads | awk --assign search='chord/' 'substr($0, 1, length(search)) == search { print }'
}

printTrackerBranchesForSync() {
    if checkTruthy "$configValue_all"; then
        printAllTrackerBranches
    else
        defaultTrackerBranch="${configValue_trackers_prefix}${configValue_trackers_name}"
        if ! git show-ref --verify --quiet "refs/heads/${defaultTrackerBranch}"; then
            printf '%sERROR: %s %s%s\n' "$formatError" "Default tracker branch doesn't exist:" "$defaultTrackerBranch" "$formatErrorEnd" >&2
            return 1
        fi
        printf '%s\n' "$defaultTrackerBranch"
        return 0
    fi
}

setupRemoteNameAndRemoteBranchForSync() { # $1: trackerBranch
    remoteName="$( git config "branch.${1}.remote" )"
    remoteBranch="$( git for-each-ref --format='%(upstream:short)' "refs/heads/${1}" )"
    if [ -z "$remoteBranch" ]; then
        logInfoMessage "No remote is set for ${1}"
        if ! checkTruthy "$configValue_trackers_remotes_allowautoassociate"; then
            logInfoMessage "Skip ${1}, remote autoassociate is disabled"
            return
        fi
        logInfoMessage "Setup remote for ${1}"
        if [ -z "$configValue_trackers_remotes_default" ]; then
            logWarningMessage 'No default remote is set'
            return
        elif ! git remote get-url "$configValue_trackers_remotes_default" > /dev/null 2>/dev/null; then
            logWarningMessage "The default remote doesn't exist: ${configValue_trackers_remotes_default}"
            return
        fi
        remoteName="$configValue_trackers_remotes_default"
        remoteBranch="$1"
        if ! checkTruthy "$configValue_dryrun"; then
            if ! git branch --set-upstream-to="${configValue_trackers_remotes_default}/${remoteBranch}" "$1"; then
                logWarningMessage "Failed to setup remote for ${1}"
                return
            fi
        fi
    fi
}

if [ "$subcommand" = 'help' ] || [ "$subcommand" = '-h' ]; then
    case "$command" in
        help|-h)
            printTitle 'git chord help'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord (-h | help)'
            printSubtitle 'Example:'
            printCodeBlock 'git chord help'
            printSubtitle 'Description:'
            printParagraph 'Prints information about the available subcommands and options.'
            exit 0
            ;;
        version|-v)
            printTitle 'git chord version'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord (-v | version)'
            printSubtitle 'Example:'
            printCodeBlock 'git chord version'
            printSubtitle 'Description:'
            printParagraph 'Prints version of the git chord extension.'
            exit 0
            ;;
        config)
            printTitle 'git chord config'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord config [list]'
            printCodeBlock 'git chord config get <key>'
            printCodeBlock 'git chord config set <key> <value>'
            printSubtitle 'Example:'
            printCodeBlock 'git chord config set annotatedtags.store.enabled false'
            printSubtitle 'Description:'
            printParagraph \
                'Prints information about the configuration of the git chord extension,' \
                'or changes a configuration value for the current git repository.' \
            ;
            printSubtitle 'Sub-subcommands:'
            printParagraph \
                '(**list**): This is the default command.' \
                'Lists all the available configuration keys and their values.' \
                'Using the (`--default`) option you can see the defaults only,' \
                'this option works out of git repositories too.' \
                'Using the (`--all`) option you can list the ad hoc command line options too.' \
            ;
            printParagraph \
                '(**get**): Gets the value of a given configuration key.' \
                'Using the (`--default`) option you can see the default value,' \
                'this option works out of git repositories too.' \
            ;
            printParagraph \
                '(**set**): Changes the value of a given configuration key.' \
                'You need to specify the key first, then the value.' \
                'This sub-subcommand works only inside a git repository,' \
                'and will save the value as a repository scoped git config' \
                'using the prefix '\''(`chord.`)'\'' in the key.' \
            ;
            exit 0
            ;;
        snapshot)
            printTitle 'git chord snapshot'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord snapshot [<name>]'
            printCodeBlock 'git chord snapshot - <branch>'
            printSubtitle 'Example:'
            printCodeBlock 'git chord snapshot my-snapshots'
            printSubtitle 'Description:'
            printParagraph \
                'Creates and saves a snapshot of the entire state of the repository, based on the configuration.' \
                'If you use no parameters, the default tracker branch name will be used.' \
                'If you use the (`<name>`) parameter, this branch name will be used with the default prefix.' \
                'If you use the '\''(`-`)'\'' argument,' \
                'then the (`<branch>`) parameter will be interpreted as a full branch name.' \
                'In any case, the tracker branch will be created if not exist.' \
            ;
            printParagraph \
                'All the dependency commits (heads of branches, tags, staging area state etc.)' \
                'will be stored by their name and full commit hash,' \
                'and all such commit hashes will be additional parents of the commit.' \
                'The first parent is always the previous commit of the tracker branch,' \
                'if there is no such previous commit, then an empty commit will be prepended.' \
                'You can inspect the snapshot history by following the first-parent history.' \
            ;
            exit 0
            ;;
        apply)
            printTitle 'git chord apply'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord apply [<name>] [-n]'
            printCodeBlock 'git chord apply - <revision>'
            printSubtitle 'Example:'
            printCodeBlock 'git chord apply -3'
            printSubtitle 'Description:'
            printParagraph \
                'Applies the specified stored state.' \
                'If you use no parameters, last state on the default tracker branch will be applied' \
                'If you use the (`<name>`) parameter, this branch name, with the default prefix, will be used instead' \
                'In these cases, if you use the (`-<n>`) parameter, where (`<n>`) is a non-negative whole number,' \
                'you will refer to the nth ascendant in the first-parent history.' \
                'If you use the '\''(`-`)'\'' argument,' \
                'then the (`<revision>`) parameter will be interpreted as an arbitrary committish' \
                'It will indicate an error if the specified revision is not a snapshot commit.' \
            ;
            printParagraph \
                'Be careful when using the working tree, as this will cause a hard reset.' \
                'In this case, all local changes will be saved into the stash, then erased from the file system.' \
            ;
            exit 0
            ;;
        state)
            printTitle 'git chord state'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord state'
            printSubtitle 'Exaple:'
            printCodeBlock 'git chord state'
            printSubtitle 'Description:'
            printParagraph \
                'Prints the current state in YAML format,' \
                'based on the current configuration.' \
                'This is the same content that will be saved using the (`snapshot`) command.' \
            ;
            exit 0
            ;;
        show)
            printTitle 'git chord show'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord show [<name>] [-<n>]'
            printCodeBlock 'git chord show - <revision>'
            printSubtitle 'Example:'
            printCodeBlock 'git chord show -3'
            printSubtitle 'Description:'
            printParagraph \
                'Prints a stored state in YAML format.' \
                'If you use no parameters, last commit on the default tracker branch will be retrieved.' \
                'If you use the (`<name>`) parameter, this branch name, with the default prefix, will be retrieved.' \
                'In these cases, if you use the (`-<n>`) parameter, where (`<n>`) is a non-negative whole number,' \
                'you will refer to the nth ascendant in the first-parent history.' \
                'If you use the '\''(`-`)'\'' argument,' \
                'then the (`<revision>`) parameter will be interpreted as an arbitrary committish' \
                'It will indicate an error if the specified revision is not a snapshot commit.' \
            ;
            exit 0
            ;;
        list)
            printTitle 'git chord list'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord list [<name>] [-<n>]'
            printCodeBlock 'git chord list --all'
            printSubtitle 'Example:'
            printCodeBlock 'git chord list -3'
            printSubtitle 'Description:'
            printParagraph \
                'Lists the previously stored snapshots.' \
                'If you do not specify the (`<name>`) parameter, the default tracker branch will be used.' \
                'If you specify the (`<n>`) parameter, the output will be restricted to this number of entries.' \
                'If you use the (`--all`) option, all the tracker branches using the default prefix will be listed,' \
                'even if the <name> parameter is specified.' \
            ;
            printParagraph \
                'The output is generated by the (`git log`) command using the (`--oneline`) format.' \
                'If you disable colors (e.g. by using the (`--no-color`) option),' \
                'then the (`--color=never`) argument will be appended to the (`git log`) command.' \
                'If you use the (`--markdown`) option, the list will be rendered as simple Markdown list' \
            ;
            exit 0
            ;;
        diff)
            printTitle 'git chord diff'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord diff [<name>] [-<n> [-<m>]]'
            printCodeBlock 'git chord diff <name> [-<n>] <name2> [-m]'
            printCodeBlock 'git chord diff - <revision> [<revision2>]'
            printSubtitle 'Example:'
            printCodeBlock 'git chord diff -5 -2'
            printSubtitle 'Description:'
            printParagraph \
                'Compares the current state or a stored state to another stored state.' \
                'If you specify a single base revision (using neither (`<name2>`), (`<m>`), nor (`<revision2>`)),' \
                'you will compare the current state with this specified revision.' \
                'the current state means the data that would be printed using the (`state`) subcommand.' \
                'The selection of the base revision follows the same rules as for the (`show`) command.' \
                'If you specify a second revision, it will be used for the comparison instead of the current state.' \
                '(`<name2>`) will be interpreted in the same way as (`<name>`),' \
                '(`<m>`) as (`<n>`),' \
                'and (`<revision2>`) as (`<revision>`)' \
            ;
            exit 0
            ;;
        delete)
            printTitle 'git chord delete'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord delete [<name>] [-<n>]'
            printSubtitle 'Example:'
            printCodeBlock 'git chord delete -3'
            printSubtitle 'Description:'
            printParagraph \
                'Deletes a stored snapshot.' \
                'If you use no parameters, last commit on the default tracker branch will be deleted.' \
                'If you use the (`<name>`) parameter, this branch name, with the default prefix, will be used,' \
                'and the last commit in this branch will be deleted.' \
                'In these cases, if you use the (`-<n>`) parameter, where (`<n>`) is a non-negative whole number,' \
                'you will refer to the nth ascendant in the first-parent history.' \
                'If you refer to a non-snapshot commit, no deletion will be done,' \
                'and an error message will be printed.' \
            ;
            exit 0
            ;;
        push)
            printTitle 'git chord push'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord push'
            printSubtitle 'Example:'
            printCodeBlock 'git chord push'
            printSubtitle 'Description:'
            printParagraph \
                'Pushes the default or all (using the (`--all`) option) tracker branches.' \
                'In the case of branches for which a remote is already set, this remote will be used.' \
                'The other branches will be assigned the default remote' \
                '(config key: (`trackers.remotes.default`)), if the automatic association' \
                '(config key: (`trackers.remotes.allowautoassociate`)) is enabled.' \
                'The operation is not atomic, each branch will be handled separately,' \
                'and in case of error, the operation will be continued.' \
            ;
            exit 0
            ;;
        pull)
            printTitle 'git chord pull'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord pull'
            printSubtitle 'Example:'
            printCodeBlock 'git chord pull'
            printSubtitle 'Description:'
            printParagraph \
                'Fetches and rebases the default or all (using the (`--all`) option) tracker branches.' \
                'In the case of branches for which a remote is already set, this remote will be used.' \
                'The other branches will be assigned the default remote' \
                '(config key: (`trackers.remotes.default`)), if the automatic association' \
                '(config key: (`trackers.remotes.allowautoassociate`)) is enabled.' \
                'The operation is not atomic, each branch will be handled separately,' \
                'and in case of error, the operation will be continued.' \
            ;
            exit 0
            ;;
        spec)
            printTitle 'git chord spec'
            printSubtitle 'Usage:'
            printCodeBlock 'git chord spec <requestType>'
            printSubtitle 'Example:'
            printCodeBlock 'git chord spec commands'
            printSubtitle 'Description:'
            printParagraph \
                'Gets special information mainly for machine processing.' \
                'The special information will be identified by the (`<requestType>`).' \
            ;
            printSubtitle 'Request types:'
            printParagraph \
                '(**commands**): Lists the available commands line-by-line,' \
                'followed by the subcommands in the same line, space-separated, if any.' \
            ;
            printParagraph \
                '(**options**): Lists the available options (starting with (`--`)) line-by-line.' \
            ;
            exit 0
            ;;
        *)
            printf '%sERROR: %s: %s%s\n' "$formatError" 'No help for command' "$command" "$formatErrorEnd" >&2
            exit 1
            ;;
    esac
fi

case "$command" in
    help|-h)
        printGrandTitle 'HELP for Git Chord'
        printSubtitle 'Usage:'
        printCodeBlock 'git chord <subcommand> [<arguments...>] [<options...>]'
        printSubtitle 'Example:'
        printCodeBlock 'git chord state --verbose'
        printSubtitle 'Subcommands:'
        commandNames="$( printf '%s\n' "$COMMANDS" | cut -d ' ' -f 1 )"
        commandComments="$( printf '%s\n' "$COMMANDS" | sed -E 's/^.* # ([^#]*)$/\1/' )"
        commandI=0
        printf '%s\n' "$commandNames" | while IFS= read -r commandName; do
            commandI=$(( commandI + 1 ))
            commandComment="$( getNthLine "$commandComments" "$commandI" )"
            printCommandShortDescription "$commandName" "$commandComment"
        done
        printSubtitle 'Options:'
        configKeys="$( printf '%s\n'  "$defaults" | cut -d ' ' -f 1 )"
        defaultValues="$( printf '%s\n'  "$defaults" | cut -d ' ' -f 2- )"
        configComments="$( printf '%s\n'  "$OPTIONS" | sed -E 's/^.* # ([^#]*)$/\1/' )"
        configI=0
        printf '%s\n' "$configKeys" | while IFS= read -r configKey; do
            configI=$(( configI + 1 ))
            defaultValue="$( printf '%s\n'  "$defaultValues" | sed "${configI}q;d" )"
            configComment="$( printf '%s\n'  "$configComments" | sed "${configI}q;d" )"
            optionPrefix='--'
            if checkBoolValue "$defaultValue"; then
                optionPrefix='--[no-]'
                configComment="$( printf '%s\n' "$configComment" | sed -E 's/ /\/disables /' )"
            fi
            optionName="${optionPrefix}$( printf '%s\n' "$configKey" | tr '.' '-' )"
            printOptionShortDescription "$optionName" "$defaultValue" "$configComment"
        done
        printSubtitle 'Exit statuses:'
        printParagraph '(**0**) - in case of success'
        printParagraph '(**1**) - in case of error'
        printParagraph '(**2**) - if the action was aborted due to dryrun mode'
        exit 0
        ;;
    version|-v)
        if checkTruthy "$configValue_markdown"; then
            printTitle 'Version information'
            printParagraph "Git version: (\`$( git --version | sed -E 's/.* //' )\`)"
            printParagraph "Chord version: (\`${VERSION}\`)"
        elif checkTruthy "$configValue_verbose"; then
            git --version
            printf 'chord version %s\n' "$VERSION"
        else
            printf '%s\n' "$VERSION"
        fi
        exit 0
        ;;
    config)
        if checkTruthy "$configValue_defaults"; then
            if [ -z "$subcommand" ] || [ "$subcommand" = 'list' ]; then
                filteredDefaults="$defaults"
                if ! checkTruthy "$configValue_all"; then
                    filteredDefaults="$( printf '%s\n' "$defaults" | grep -F '.' )"
                fi
                if checkTruthy "$configValue_verbose" || checkTruthy "$configValue_markdown"; then
                    printTitle 'Default configuration'
                    printTableTitle 'Key:' 40 'Default:' 15
                    printTableSeparator 40 15
                    printf '%s\n' "$filteredDefaults" | while IFS= read -r line; do
                        configKey="$( printf '%s\n' "$line" | cut -d ' ' -f 1 )"
                        configDefaultValue="$( printf '%s\n' "$line" | cut -d ' ' -f 2- )"
                        printTableRow \
                            "${formatCode}${configKey}${formatCodeEnd}" 40 \
                            "${formatCode}${configDefaultValue}${formatCodeEnd}" 15
                    done
                    echo ''
                else
                    printf '%s\n' "$filteredDefaults"
                fi
                exit 0
            elif [ "$subcommand" = 'get' ]; then
                configKey="$( getNthLine "$nonOptArgs" 2 )"
                configDefaultValue="$( getMapValue "$defaults" "$configKey" )"
                if checkTruthy "$configValue_markdown"; then
                    printParagraph "Key: (\`${configKey}\`)"
                    printParagraph "Default: (\`${configDefaultValue}\`)"
                elif checkTruthy "$configValue_verbose"; then
                    printf 'Key:     %s%s%s\n' "$formatCode" "$configKey" "$formatCodeEnd"
                    printf 'Default: %s%s%s\n' "$formatCode" "$configDefaultValue" "$formatCodeEnd"
                else
                    printf '%s\n' "$configDefaultValue"
                fi
                exit 0
            elif [ "$subcommand" = 'set' ]; then
                printf '%sERROR: %s%s\n' "$formatError" 'Default value can not be changed' "$formatErrorEnd" >&2
                exit 1
            fi
            exit 0
        fi
        ;;
    spec)
        if [ "$subcommand" = 'commands' ]; then
            printf '%s\n' "$COMMANDS" | sed -E 's/ #.*$//'
        elif [ "$subcommand" = 'options' ]; then
            printf '%s\n' "$defaults" | while IFS=' ' read -r configKey defaultValue; do
                dashedConfigKey="$( printf '%s\n' "$configKey" | sed -E 's/\./-/g' )"
                if checkBoolValue "$defaultValue"; then
                    printf -- '--%s\n' "$dashedConfigKey"
                    printf -- '--no-%s\n' "$dashedConfigKey"
                else
                    printf -- '--%s=\n' "$dashedConfigKey"
                fi
            done
        elif [ -z "$subcommand" ]; then
            printf '%sERROR: %s%s\n' "$formatError" 'No request type was given' "$formatErrorEnd" >&2
            exit 1
        else
            printf '%sERROR: %s: %s%s\n' "$formatError" 'Unknown request type' "$subcommand" "$formatErrorEnd" >&2
            exit 1
        fi
        exit 0
        ;;
esac

if ! git rev-parse --git-dir > /dev/null 2>&1; then
    printf '%sERROR: %s%s\n' "$formatError" 'Not a git repository' "$formatErrorEnd" >&2
    exit 1
fi

case "$command" in
    config)
        if [ -z "$subcommand" ] || [ "$subcommand" = 'list' ]; then
            filteredConfig="$config"
            if ! checkTruthy "$configValue_all"; then
                filteredConfig="$( printf '%s\n' "$config" | grep -F '.' )"
            fi
            if checkTruthy "$configValue_verbose" || checkTruthy "$configValue_markdown"; then
                printTitle 'Current configuration'
                printTableTitle 'Key:' 40 'Default:' 15 'Value:' 20
                printTableSeparator 40 15 20
                printf '%s\n' "$filteredConfig" | while IFS= read -r line; do
                    configKey="$( printf '%s\n' "$line" | cut -d ' ' -f 1 )"
                    configValue="$( printf '%s\n' "$line" | cut -d ' ' -f 2- )"
                    configDefaultValue="$( getMapValue "$defaults" "$configKey" )"
                    printTableRow \
                        "${formatCode}${configKey}${formatCodeEnd}" 40 \
                        "${formatCode}${configDefaultValue}${formatCodeEnd}" 15 \
                        "${formatCode}${configValue}${formatCodeEnd}" 20
                done
                echo ''
            else
                printf '%s\n' "$filteredConfig"
            fi
        elif [ "$subcommand" = 'get' ]; then
            configKey="$( getNthLine "$nonOptArgs" 2 )"
            configDefaultValue="$( getMapValue "$defaults" "$configKey" )"
            configValue="$( getMapValue "$config" "$configKey" )"
            if checkTruthy "$configValue_markdown"; then
                printParagraph "Key: (\`${configKey}\`)"
                printParagraph "Default: (\`${configDefaultValue}\`)"
                printParagraph "Value: (\`${configValue}\`)"
            elif checkTruthy "$configValue_verbose"; then
                printf 'Key:     %s%s%s\n' "$formatCode" "$configKey" "$formatCodeEnd"
                printf 'Default: %s%s%s\n' "$formatCode" "$configDefaultValue" "$formatCodeEnd"
                printf 'Value:   %s%s%s\n' "$formatCode" "$configValue" "$formatCodeEnd"
            else
                printf '%s\n' "$configValue"
            fi
        elif [ "$subcommand" = 'set' ]; then
            configKey="$( getNthLine "$nonOptArgs" 2 )"
            configNewValue="$( getNthLine "$nonOptArgs" 3 )"
            if checkTruthy "$configValue_verbose"; then
                configOldValue="$( getMapValue "$config" )"
                printf 'Set %s%s%s from '\''%s%s%s'\'' to '\''%s%s%s'\''\n' \
                    "$formatBold" "$configKey" "$formatBoldEnd" \
                    "$formatBold" "$configOldValue" "$formatBoldEnd" \
                    "$formatBold" "$configNewValue" "$formatBoldEnd"
            fi
            if checkTruthy "$configValue_dryrun"; then
                exit 2
            fi
            if ! git config "chord.${configKey}" "$configNewValue"; then
                printf '%sERROR: %s%s\n' "$formatError" 'Failed to set value' "$formatErrorEnd" >&2
                exit 1
            fi
        else
            printf '%sERROR: %s: %s%s\n' "$formatError" 'Unknown subcommand of config' "$subcommand" "$formatErrorEnd" >&2
            exit 1
        fi
        exit 0
        ;;
    snapshot)
        stateYaml="$( printState )${NL}"
        nameArg="$( getNthLine "$nonOptArgs" 1 )"
        if [ -z "$nameArg" ]; then
            targetBranch="${configValue_trackers_prefix}${configValue_trackers_name}"
        elif [ "$nameArg" = '-' ]; then
            branchArg="$( getNthLine "$nonOptArgs" 2 )"
            if [ -n "$branchArg" ]; then
                targetBranch="$branchArg"
            else
                printf '%sERROR: %s%s\n' "$formatError" 'No branch name was specified' "$formatErrorEnd" >&2
                exit 1
            fi
        elif checkStartsWith "$nameArg" '-'; then
            stateRevision="${configValue_trackers_prefix}${configValue_trackers_name}$( printf '%s\n' "$nameArg" | sed -E 's/^\-/~/' )"
        else
            targetBranch="${configValue_trackers_prefix}${nameArg}"
        fi
        firstParentCommitId="$( git rev-parse --verify --quiet "$targetBranch" )"
        if [ -z "$firstParentCommitId" ]; then
            emptyTreeId="$( git hash-object -t tree /dev/null )"
            firstParentCommitId="$( git commit-tree "$emptyTreeId" -m "Chord tracker root commit for ${targetBranch}" )"
        fi
        parentCommitIds="${firstParentCommitId}${NL}"
        if checkTruthy "$configValue_branches_store_enabled"; then
            while IFS=' ' read -r branchName commitId; do
                parentCommitIds="${parentCommitIds}${commitId}${NL}"
            done <<EOF
$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'branches:' | reformatYamlKeyValueLines ' ' )
EOF
        fi
        if checkTruthy "$configValue_annotatedtags_store_enabled"; then
            annotatedTagsYaml="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'annotatedTags:' )"
            while IFS= read -r keyPrefix; do
                commitId="$( printf '%s\n' "$annotatedTagsYaml" | extractYamlSubLines | extractYamlValue "commitId:" )"
                parentCommitIds="${parentCommitIds}${commitId}${NL}"
            done <<EOF
$( printf '%s\n' "$annotatedTagsYaml" | getYamlKeyPrefixes )
EOF
        fi
        if checkTruthy "$configValue_lightweighttags_store_enabled"; then
            while IFS=' ' read -r branchName commitId; do
                parentCommitIds="${parentCommitIds}${commitId}${NL}"
            done <<EOF
$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'lightWeightTags:' | reformatYamlKeyValueLines ' ' )
EOF
        fi
        if checkTruthy "$configValue_head_store_enabled"; then
            commitId="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'head:' | extractYamlValue 'commitId:' )"
            if [ -n "$commitId" ]; then
                parentCommitIds="${parentCommitIds}${commitId}${NL}"
            fi
        fi
        if checkTruthy "$configValue_stagingarea_store_enabled"; then
            treeId="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'stagingArea:' | extractYamlValue 'treeId:' )"
            commitId="$( git commit-tree "$treeId" -m "Chord stating area state" )"
            parentCommitIds="${parentCommitIds}${commitId}${NL}"
        fi
        if checkTruthy "$configValue_workingtree_store_enabled"; then
            treeId="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'workingTree:' | extractYamlValue 'treeId:' )"
            commitId="$( git commit-tree "$treeId" -m "Chord working tree state" )"
            parentCommitIds="${parentCommitIds}${commitId}${NL}"
        fi
        parentCommitIds="$( printf '%s\n' "$parentCommitIds" | deduplicateLinesStable )"
        if checkTruthy "$configValue_verbose" || checkTruthy "$configValue_markdown"; then
            printTitle 'Snapshot'
            printParagraph 'Target branch: (`'"$targetBranch"'`)'
            printSubtitle 'Parent commit ids'
            printList $parentCommitIds
            printSubtitle 'State'
            printCodeBlock "$stateYaml"
        fi
        if checkTruthy "$configValue_dryrun"; then
            exit 2
        fi
        timestamp="$( printf '%s\n' "$stateYaml" | extractYamlValue 'timestamp:' )"
        stateBlobId="$( printf '%s\n' "$stateYaml" | git hash-object -w --stdin )"
        stateTreeId="$( printf '%s %s %s\t%s\n' '100644' 'blob' "$stateBlobId" "$STATE_FILE" | git mktree )"
        stateParentIdsParams=$( printf '%s' "$parentCommitIds" | sed -E 's/^/-p /' )
        stateCommitId="$( git commit-tree "$stateTreeId" -m "Chord repository state at ${timestamp}" $stateParentIdsParams )"
        git update-ref refs/heads/"$targetBranch" "$stateCommitId"
        
        printf '%sSUCCESS: %s: %s%s\n' "$formatSuccess" 'Snapshot was successfully created' "$stateCommitId" "$formatSuccessEnd"
        
        ;;
    apply)
        
        # TODO: consider untracked files
        
        nameArg="$( getNthLine "$nonOptArgs" 1 )"
        if [ -z "$nameArg" ]; then
            stateRevision="${configValue_trackers_prefix}${configValue_trackers_name}"
        elif [ "$nameArg" = '-' ]; then
            revisionArg="$( getNthLine "$nonOptArgs" 2 )"
            if [ -n "$revisionArg" ]; then
                stateRevision="$revisionArg"
            else
                printf '%sERROR: %s%s\n' "$formatError" 'No revision was specified' "$formatErrorEnd" >&2
                exit 1
            fi
        elif checkStartsWith "$nameArg" '-'; then
            stateRevision="${configValue_trackers_prefix}${configValue_trackers_name}$( printf '%s\n' "$nameArg" | sed -E 's/^\-/~/' )"
        else
            stateRevision="${configValue_trackers_prefix}${nameArg}"
            offsetArg="$( getNthLine "$nonOptArgs" 2 )"
            if checkStartsWith "$offsetArg" '-'; then
                stateRevision="${stateRevision}$( printf '%s\n' "$offsetArg" | sed -E 's/^\-/~/' )"
            elif [ -n "$offsetArg" ]; then
                printf '%sERROR: %s: %s%s\n' "$formatError" 'Illegal offset argument' "$offsetArg" "$formatErrorEnd" >&2
                exit 1
            fi
        fi
        revPath="${stateRevision}:${STATE_FILE}"
        if ! stateYaml="$( git show "$revPath" 2>/dev/null )"; then
            printf '%sERROR: %s %s%s\n' "$formatError" 'Failed to load' "$revPath" "$formatErrorEnd" >&2
            exit 1
        fi
        
        fixedRefMap=""
        mergedBranchesTable=''
        mergedAnnotatedTagsTable=''
        mergedLightWeightTagsTable=''
        
        currentBranchesMap="$( printMatchingBranches "$configValue_branches_apply_regex" )"
        if checkTruthy "$configValue_branches_apply_enabled"; then
            if printf '%s\n' "$stateYaml" | checkHasPrefix 'branches:'; then
                storedBranchesMap="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'branches:' | reformatYamlKeyValueLines ' ' | grep -E "^${configValue_branches_apply_regex} " )"
                mergedBranchesTable="$( mergeMaps "${currentBranchesMap}${NL}" "${storedBranchesMap}${NL}" )"
            else
                logWarningMessage 'Branches section not found in the loaded state'
            fi
            if checkTruthy "$configValue_branches_apply_allowremove"; then
                printf '%s\n' "$mergedBranchesTable" | grep -E ' 1 ' | while IFS=' ' read -r branchName source commitId1 commitId2; do
                    logInfoMessage "Delete branch: ${branchName}"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if ! gitError="$( catchSystemErrorMessage git branch -D "$branchName" )"; then
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to delete branch' "$branchName" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                done
                currentBranchesMap=''
            fi
        elif printf '%s\n' "$stateYaml" | checkHasPrefix 'branches:'; then
            logWarningMessage 'Applying branches is disabled'
        fi
        fixedRefMap="$( appendLine "$fixedRefMap" "$currentBranchesMap" )"
        
        currentAnnotatedTagsMap="$( printMatchingAnnotatedTags "$configValue_annotatedtags_apply_regex" )"
        if checkTruthy "$configValue_annotatedtags_apply_enabled"; then
            if printf '%s\n' "$stateYaml" | checkHasPrefix 'annotatedTags:'; then
                storedAnnotatedTagsMap="$( extractAnnotatedTagRefKeyValues "$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'annotatedTags:' )" | grep -E "^${configValue_annotatedtags_apply_regex} " )"
                mergedAnnotatedTagsTable="$( mergeMaps "${currentAnnotatedTagsMap}${NL}" "${storedAnnotatedTagsMap}${NL}" )"
            else
                logWarningMessage 'Annotated tags section not found in the loaded state'
            fi
            if checkTruthy "$configValue_annotatedtags_apply_allowremove"; then
                printf '%s\n' "$mergedAnnotatedTagsTable" | grep -E ' 1 ' | while IFS=' ' read -r tagName source tagId1 tagId2; do
                    logInfoMessage "Delete annotated tag: ${tagName}"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if ! gitError="$( catchSystemErrorMessage git tag -d "$tagName" )"; then
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to delete annotated tag' "$tagName" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                done
                currentBranchesMap=''
            fi
        elif printf '%s\n' "$stateYaml" | checkHasPrefix 'annotatedTags:'; then
            logWarningMessage 'Applying annotated tags is disabled'
        fi
        fixedRefMap="$( appendLine "$fixedRefMap" "$currentAnnotatedTagsMap" )"
        
        currentLightWeightTagsMap="$( printMatchingLightWeightTags "$configValue_lightweighttags_apply_regex" )"
        if checkTruthy "$configValue_lightweighttags_apply_enabled"; then
            if printf '%s\n' "$stateYaml" | checkHasPrefix 'lightWeightTags:'; then
                storedLightWeightTagsMap="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'lightWeightTags:' | reformatYamlKeyValueLines ' ' | grep -E "^${configValue_lightweighttags_apply_regex} " )"
                mergedLightWeightTagsTable="$( mergeMaps "${currentLightWeightTagsMap}${NL}" "${storedLightWeightTagsMap}${NL}" )"
            else
                logWarningMessage 'Light-weight tags section not found in the loaded state'
            fi
            if checkTruthy "$configValue_lightweighttags_apply_allowremove"; then
                printf '%s\n' "$mergedLightWeightTagsTable" | grep -E ' 1 ' | while IFS=' ' read -r tagName source commitId1 commitId2; do
                    if ! checkTruthy "$configValue_dryrun"; then
                        if ! gitError="$( catchSystemErrorMessage git tag -d "$tagName" )"; then
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to delete light-weight tag' "$tagName" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                done
                currentBranchesMap=''
            fi
        elif printf '%s\n' "$stateYaml" | checkHasPrefix 'lightWeightTags:'; then
            logWarningMessage 'Applying light-weight tags is disabled'
        fi
        fixedRefMap="$( appendLine "$fixedRefMap" "$currentLightWeightTagsMap" )"
        
        fixedRefs="$( printf '%s\n' "$fixedRefMap" | cut -d ' ' -s -f 1 )${NL}"
        
        if checkTruthy "$configValue_branches_apply_enabled"; then
            printf '%s\n' "$mergedBranchesTable" | grep -E ' [2*] ' | while IFS=' ' read -r branchName source commitId1 commitId2; do
                currentCommitId="$commitId1"
                targetCommitId="$commitId2"
                if [ "$source" = '2' ]; then
                    currentCommitId=''
                    targetCommitId="$commitId1"
                fi
                if [ "$source" = '2' ]; then
                    if checkTruthy "$configValue_branches_apply_allowadd"; then
                        if ! printf '%s\n' "$fixedRefs" | grep -qE "$branchName"; then
                            logInfoMessage "Add branch ${branchName} pointing to ${targetCommitId}"
                            if ! checkTruthy "$configValue_dryrun"; then
                                if ! gitError="$( catchSystemErrorMessage git branch "$branchName" "$targetCommitId" )"; then
                                    printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to add branch' "$branchName" "$gitError" "$formatErrorEnd" >&2
                                fi
                            fi
                        else
                            logWarningMessage "Failed to set branch to ${targetCommitId}, it's reserved by a non-removable object"
                        fi
                    fi
                elif [ "$commitId1" = "$commitId2" ]; then
                    logInfoMessage "Branch ${branchName} staying at ${currentCommitId}"
                else
                    currentHead="$( getHeadReference )"
                    if [ "$branchName" = "$currentHead" ]; then
                        logInfoMessage "Move current branch ${branchName} from ${currentCommitId} to ${targetCommitId}"
                        if ! checkTruthy "$configValue_dryrun"; then
                            if ! gitError="$( catchSystemErrorMessage git reset --soft "$targetCommitId" )"; then
                                printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move current branch' "$branchName" "$gitError" "$formatErrorEnd" >&2
                            fi
                        fi
                    else
                        logInfoMessage "Move branch ${branchName} from ${currentCommitId} to ${targetCommitId}"
                        if ! checkTruthy "$configValue_dryrun"; then
                            if ! gitError="$( catchSystemErrorMessage git branch -f "$branchName" "$targetCommitId" )"; then
                                printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move branch' "$branchName" "$gitError" "$formatErrorEnd" >&2
                            fi
                        fi
                    fi
                fi
            done
        fi
        if checkTruthy "$configValue_annotatedtags_apply_enabled"; then
            annotatedTagsYaml="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'annotatedTags:' )"
            printf '%s\n' "$mergedAnnotatedTagsTable" | grep -E ' [2*] ' | while IFS=' ' read -r tagName source tagId1 tagId2; do
                currentTagId="$tagId1"
                targetTagId="$tagId2"
                if [ "$source" = '2' ]; then
                    currentTagId=''
                    targetTagId="$tagId1"
                fi
                tagYaml="$( printf '%s\n' "$annotatedTagsYaml" | extractYamlSubLines "$( printf '%s\n' "$tagName" | quoteYamlValue ):" )"
                tagCommitId="$( printf '%s\n' "$tagYaml" | extractYamlValue 'commitId:' )"
                tagMessage="$( printf '%s\n' "$tagYaml" | extractYamlValue 'message:' )" # FIXME: removes all the trailing newlines
                if [ "$source" = '2' ]; then
                    if ! printf '%s\n' "$fixedRefs" | grep -qE "$tagName"; then
                        logInfoMessage "Add annotated tag ${tagName} pointing to tag object ${targetTagId} (commit id: ${tagCommitId})"
                        if ! checkTruthy "$configValue_dryrun"; then
                            if ! gitError="$( catchSystemErrorMessage git tag -a "$tagName" -m "$tagMessage" )"; then
                                printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to add annotated tag' "$tagName" "$gitError" "$formatErrorEnd" >&2
                            fi
                        fi
                    else
                        logWarningMessage "Failed to set annotated tag to ${targetTagId}, it's reserved by a non-removable object"
                    fi
                elif [ "$tagId1" = "$tagId2" ]; then
                    logInfoMessage "Annotated tag ${tagName} staying at ${currentTagId}"
                else
                    currentTagCommitId="$( git rev-parse "$tagName" )"
                    logInfoMessage "Move annotated tag ${tagName} from tag object ${currentTagId} (commit id: ${currentTagCommitId}) to tab object ${targetTagId} (commit id: ${tagCommitId})"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if ! gitError="$( catchSystemErrorMessage git tag -f -a "$tagName" -m "$tagMessage" )"; then
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move annotated tag' "$tagName" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                fi
            done
        fi
        if checkTruthy "$configValue_lightweighttags_apply_enabled"; then
            printf '%s\n' "$mergedLightWeightTagsTable" | grep -E ' [2*] ' | while IFS=' ' read -r tagName source commitId1 commitId2; do
                currentCommitId="$commitId1"
                targetCommitId="$commitId2"
                if [ "$source" = '2' ]; then
                    currentCommitId=''
                    targetCommitId="$commitId1"
                fi
                if [ "$source" = '2' ]; then
                    if ! printf '%s\n' "$fixedRefs" | grep -qE "$tagName"; then
                        logInfoMessage "Add light-weight tag ${tagName} pointing to ${targetCommitId}"
                        if ! checkTruthy "$configValue_dryrun"; then
                            if ! gitError="$( catchSystemErrorMessage git tag "$tagName" "$targetCommitId" )"; then
                                printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to add light-weight tag' "$tagName" "$gitError" "$formatErrorEnd" >&2
                            fi
                        fi
                    else
                        logWarningMessage "Failed to set annotated tag to ${targetCommitId}, it's reserved by a non-removable object"
                    fi
                elif [ "$commitId1" = "$commitId2" ]; then
                    logInfoMessage "Light-weight tag ${tagName} staying at ${currentCommitId}"
                else
                    logInfoMessage "Move light-weight tag ${tagName} from ${currentCommitId} to ${targetCommitId}"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if ! gitError="$( catchSystemErrorMessage git update-ref refs/tags/"$tagName" "$targetCommitId" )"; then
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move light-weight-tag' "$tagName" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                fi
            done
        fi
        
        if checkTruthy "$configValue_head_apply_enabled"; then
            if printf '%s\n' "$stateYaml" | checkHasPrefix 'head:'; then
                headState="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'head:' )"
                headTarget="$( printf '%s\n' "$headState" | extractYamlValue 'pointingTo:' )"
                headTargetCommitId="$( printf '%s\n' "$headState" | extractYamlValue 'commitId:' )"
                headCurrent="$( getHeadPointingTo )"
                headCurrentCommitId="$( getHeadCommitId )"
                if checkTruthy "$configValue_head_apply_sticktocommit" && [ "$headTargetCommitId" != "$headCurrentCommitId" ]; then
                    logWarningMessage "HEAD will be forced to commit ${headTargetCommitId}"
                    headTarget="$headTargetCommitId"
                fi
                if [ "$headTarget" = "$headCurrent" ]; then
                    logInfoMessage "HEAD staying at ${headCurrent}"
                else
                    logInfoMessage "Move HEAD from ${headCurrent} to ${headTarget}"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if ! gitError="$( catchSystemErrorMessage git checkout "$headTarget" )"; then
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move HEAD to' "$headTarget" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                fi
            else
                logWarningMessage 'HEAD section not found in the loaded state'
            fi
        elif printf '%s\n' "$stateYaml" | checkHasPrefix 'head:'; then
            logWarningMessage 'Applying HEAD is disabled'
        fi
        
        stagingAreaWasSet=''
        if checkTruthy "$configValue_stagingarea_apply_enabled"; then
            if printf '%s\n' "$stateYaml" | checkHasPrefix 'stagingArea:'; then
                stagingAreaState="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'stagingArea:' )"
                stagingAreaTarget="$( printf '%s\n' "$stagingAreaState" | extractYamlValue 'treeId:' )"
                stagingAreaCurrent="$( git write-tree )"
                if [ "$stagingAreaTarget" = "$stagingAreaCurrent" ]; then
                    logInfoMessage "Staging area staying at tree ${headCurrent}"
                else
                    logInfoMessage "Move staging area from ${stagingAreaCurrent} to ${stagingAreaTarget}"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if gitError="$( catchSystemErrorMessage git read-tree "$stagingAreaTarget" )"; then
                            stagingAreaWasSet='1'
                        else
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move staging area to tree' "$stagingAreaTarget" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                fi
            else
                logWarningMessage 'Staging area section not found in the loaded state'
            fi
        elif printf '%s\n' "$stateYaml" | checkHasPrefix 'stagingArea:'; then
            logWarningMessage 'Applying staging area is disabled'
        fi
        if checkTruthy "$configValue_stagingarea_followhead" && [ -z "$stagingAreaWasSet" ]; then
            headTreeId="$( git rev-parse --verify -q 'HEAD^{tree}' )"
            if [ -n "$headTreeId" ]; then
                logInfoMessage "Staging area will follow HEAD to tree ${headTreeId}"
                if ! gitError="$( catchSystemErrorMessage git read-tree "$headTreeId" )"; then
                    printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move staging area to HEAD tree' "$headTreeId" "$gitError" "$formatErrorEnd" >&2
                fi
            else
                logWarningMessage 'Staging area failed to follow HEAD because HEAD has no tree'
            fi
        fi
        
        workingTreeWasSet=''
        if checkTruthy "$configValue_workingtree_apply_enabled"; then
            if printf '%s\n' "$stateYaml" | checkHasPrefix 'workingTree:'; then
                workingTreeState="$( printf '%s\n' "$stateYaml" | extractYamlSubLines 'workingTree:' )"
                workingTreeTarget="$( printf '%s\n' "$workingTreeState" | extractYamlValue 'treeId:' )"
                workingTreeCurrent="$( getWorkingTreeTreeId )"
                if [ "$workingTreeTarget" = "$workingTreeCurrent" ]; then
                    logInfoMessage "Working tree staying at tree ${headCurrent}"
                else
                    logInfoMessage "Move working tree from ${workingTreeCurrent} to ${workingTreeTarget}"
                    if ! checkTruthy "$configValue_dryrun"; then
                        if gitError="$( catchSystemErrorMessage applyWorkingTreeTreeId "$workingTreeTarget" )"; then
                            workingTreeWasSet='1'
                        else
                            printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move working tree to tree' "$workingTreeTarget" "$gitError" "$formatErrorEnd" >&2
                        fi
                    fi
                fi
            else
                logWarningMessage 'Working tree section not found in the loaded state'
            fi
        elif printf '%s\n' "$stateYaml" | checkHasPrefix 'workingTree:'; then
            logWarningMessage 'Applying working tree is disabled'
        fi
        if checkTruthy "$configValue_workingtree_followstagingarea" && [ -z "$workingTreeWasSet" ]; then
            stagingAreaTreeId="$( git write-tree )"
            logInfoMessage "Working tree will follow staging area to tree ${stagingAreaTreeId}"
            if ! gitError="$( catchSystemErrorMessage applyWorkingTreeTreeId "$stagingAreaTreeId" )"; then
                printf '%sERROR: %s: %s (%s)%s\n' "$formatError" 'Failed to move working tree to staging area tree' "$stagingAreaTreeId" "$gitError" "$formatErrorEnd" >&2
            fi
        fi
        
        printf '%sSUCCESS: %s %s%s\n' "$formatSuccess" 'Stored state was successfully reapplied from' "$stateRevision" "$formatSuccessEnd"
        
        exit 0
        ;;
    state)
        if checkTruthy "$configValue_verbose" || checkTruthy "$configValue_markdown"; then
            printTitle 'State'
            printCodeBlock "$( printState )"
        else
            printState
        fi
        exit 0
        ;;
    show)
        nameArg="$( getNthLine "$nonOptArgs" 1 )"
        if [ -z "$nameArg" ]; then
            stateRevision="${configValue_trackers_prefix}${configValue_trackers_name}"
        elif [ "$nameArg" = '-' ]; then
            revisionArg="$( getNthLine "$nonOptArgs" 2 )"
            if [ -n "$revisionArg" ]; then
                stateRevision="$revisionArg"
            else
                printf '%sERROR: %s%s\n' "$formatError" 'No revision was specified' "$formatErrorEnd" >&2
                exit 1
            fi
        elif checkStartsWith "$nameArg" '-'; then
            stateRevision="${configValue_trackers_prefix}${configValue_trackers_name}$( printf '%s\n' "$nameArg" | sed -E 's/^\-/~/' )"
        else
            stateRevision="${configValue_trackers_prefix}${nameArg}"
            offsetArg="$( getNthLine "$nonOptArgs" 2 )"
            if checkStartsWith "$offsetArg" '-'; then
                stateRevision="${stateRevision}$( printf '%s\n' "$offsetArg" | sed -E 's/^\-/~/' )"
            elif [ -n "$offsetArg" ]; then
                printf '%sERROR: %s: %s%s\n' "$formatError" 'Illegal offset argument' "$offsetArg" "$formatErrorEnd" >&2
                exit 1
            fi
        fi
        revPath="${stateRevision}:${STATE_FILE}"
        if ! stateYaml="$( git show "$revPath" 2>/dev/null )"; then
            printf '%sERROR: %s %s%s\n' "$formatError" 'Failed to load' "$revPath" "$formatErrorEnd" >&2
            exit 1
        fi
        if checkTruthy "$configValue_verbose" || checkTruthy "$configValue_markdown"; then
            printTitle 'Show stored state snapshot'
            printParagraph "Tracker revision: (\`${stateRevision}\`)"
            printSubtitle 'State'
            printCodeBlock "$stateYaml"
        else
            printf '%s\n' "$stateYaml"
        fi
        exit 0
        ;;
    list)
        nameArg="$( getNthLine "$nonOptArgs" 1 )"
        maxCount=''
        if [ -z "$nameArg" ]; then
            targetBranch="${configValue_trackers_prefix}${configValue_trackers_name}"
        elif checkStartsWith "$nameArg" '-'; then
            targetBranch="${configValue_trackers_prefix}${configValue_trackers_name}"
            maxCount="$( printf '%s\n' "$nameArg" | sed -E 's/^\-//' )"
        else
            targetBranch="${configValue_trackers_prefix}${nameArg}"
            stateRevision="$targetBranch"
            offsetArg="$( getNthLine "$nonOptArgs" 2 )"
            if checkStartsWith "$offsetArg" '-'; then
                maxCount="$( printf '%s\n' "$offsetArg" | sed -E 's/^\-//' )"
            elif [ -n "$offsetArg" ]; then
                printf '%sERROR: %s: %s%s\n' "$formatError" 'Illegal offset argument' "$offsetArg" "$formatErrorEnd" >&2
                exit 1
            fi
        fi
        trackerBranches="$targetBranch"
        if checkTruthy "$configValue_all"; then
            trackerBranches="$( printAllTrackerBranches )"
        fi
        if checkTruthy "$configValue_markdown" || checkTruthy "$configValue_verbose" || checkTruthy "$configValue_all"; then
            printTitle 'List of existing snapshots'
        fi
        
        # TODO: list commits only that contain state.yaml
        
        printf '%s\n' "$trackerBranches" | while IFS='' read -r trackerBranch; do
            if checkTruthy "$configValue_markdown" || checkTruthy "$configValue_verbose" || checkTruthy "$configValue_all"; then
                printSubtitle "Snapshots on ${trackerBranch}"
            fi
            command="git log ${targetBranch} --first-parent"
            if [ -n "$maxCount" ]; then
                command="${command} -n ${maxCount}"
            fi
            if checkTruthy "$configValue_markdown"; then
                command="${command} --oneline --color=never | escapeMarkdown | sed -E 's/^/- /'"
            elif ! checkTruthy "$configValue_color"; then
                command="${command} --oneline --color=always"
            else
                command="${command} --oneline --color=never"
            fi
            eval "$command"
            printf '\n'
        done
        exit 0
        ;;
    diff)
        nameArg="$( getNthLine "$nonOptArgs" 1 )"
        revision2=''
        if [ -z "$nameArg" ]; then
            revision1="${configValue_trackers_prefix}${configValue_trackers_name}"
        elif [ "$nameArg" = '-' ]; then
            revision1="$( getNthLine "$nonOptArgs" 2 )"
            if [ -z "$revision1" ]; then
                printf '%sERROR: %s%s\n' "$formatError" 'No revision was specified' "$formatErrorEnd" >&2
                exit 1
            fi
            revision2Arg="$( getNthLine "$nonOptArgs" 3 )"
            if [ -n "$revision2Arg" ]; then
                revision2="$revision2Arg"
            fi
        elif checkStartsWith "$nameArg" '-'; then
            revision1="${configValue_trackers_prefix}${configValue_trackers_name}$( printf '%s\n' "$nameArg" | sed -E 's/^\-/~/' )"
            n2Arg="$( getNthLine "$nonOptArgs" 2 )"
            if checkStartsWith "$n2Arg" '-'; then
                revision2="${configValue_trackers_prefix}${configValue_trackers_name}$( printf '%s\n' "$n2Arg" | sed -E 's/^\-/~/' )"
            elif [ -n "$n2Arg" ]; then
                printf '%sERROR: %s: %s%s\n' "$formatError" 'Invalid offset specifier' "$n2Arg" "$formatErrorEnd" >&2
                exit 1
            fi
        else
            revision1="${configValue_trackers_prefix}${nameArg}"
            nextArg="$( getNthLine "$nonOptArgs" 2 )"
            rev2Arg1=''
            rev2Arg2=''
            if [ -n "$nextArg" ]; then
                if checkStartsWith "$nextArg" '-'; then
                    revision1="${revision1}$( printf '%s\n' "$nextArg" | sed -E 's/^\-/~/' )"
                    nextNextArg="$( getNthLine "$nonOptArgs" 3 )"
                    if [ -n "$nextNextArg" ]; then
                        if checkStartsWith "$nextNextArg" '-'; then
                            rev2Arg1="$nameArg"
                            rev2Arg2="$nextNextArg"
                        else
                            rev2Arg1="$nextNextArg"
                            rev2Arg2="$( getNthLine "$nonOptArgs" 4 )"
                        fi
                    fi
                else
                    rev2Arg1="${nextArg}"
                    rev2Arg2="$( getNthLine "$nonOptArgs" 3 )"
                fi
                if [ -n "$rev2Arg1" ]; then
                    revision2="${configValue_trackers_prefix}${rev2Arg1}"
                    if [ -n "$rev2Arg2" ]; then
                        revision2="${revision2}$( printf '%s\n' "$rev2Arg2" | sed -E 's/^\-/~/' )"
                    fi
                fi
            fi
        fi
        revPath1="${revision1}:${STATE_FILE}"
        if ! stateYaml1="$( git show "$revPath1" 2>/dev/null )"; then
            printf '%sERROR: %s %s%s\n' "$formatError" 'Failed to load' "$revPath1" "$formatErrorEnd" >&2
            exit 1
        fi
        if [ -n "$revision2" ]; then
            revPath2="${revision2}:${STATE_FILE}"
            if ! stateYaml2="$( git show "$revPath2" 2>/dev/null )"; then
                printf '%sERROR: %s %s%s\n' "$formatError" 'Failed to load' "$revPath2" "$formatErrorEnd" >&2
                exit 1
            fi
        else
            stateYaml2="$( printState )"
        fi
        if checkTruthy "$configValue_verbose" || checkTruthy "$configValue_markdown"; then
            titleText="Diff between '(\`${revision1}\`)' and "
            if [ -n "$revision2" ]; then
                titleText="${titleText}'(\`${revision2}\`)'"
            else
                titleText="${titleText}the current state"
            fi
            printTitle "$titleText"
            output="$( {
                printRefVerboseDiff "$stateYaml1" "$stateYaml2" 'branches:' 'Branch' 'Branches' 'extractSimpleRefKeyValues'
                printRefVerboseDiff "$stateYaml1" "$stateYaml2" 'annotatedTags:' 'Annotated tag' 'Annotated tags' 'extractAnnotatedTagRefKeyValues'
                printRefVerboseDiff "$stateYaml1" "$stateYaml2" 'lightWeightTags:' 'Light-weight tag' 'Light-weight tags' 'extractSimpleRefKeyValues'
                printHeadVerboseDiff "$stateYaml1" "$stateYaml2"
                printTreeVerboseDiff "$stateYaml1" "$stateYaml2" 'stagingArea:' 'Staging area'
                printTreeVerboseDiff "$stateYaml1" "$stateYaml2" 'workingTree:' 'Working tree'
            } )"
            if [ -n "$output" ]; then
                printf '%s\n\n' "$output"
            else
                printf '%s%s%s\n\n' "$formatInfo" 'No difference detected' "$formatInfoEnd"
            fi
        else
            tempYamlFile1="$( mktemp )" # FIXME: mktemp is not POSIX
            printf '%s\n' "$stateYaml1" > "$tempYamlFile1"
            tempYamlFile2="$( mktemp )" # FIXME: mktemp is not POSIX
            printf '%s\n' "$stateYaml2" > "$tempYamlFile2"
            if checkTruthy "$configValue_color"; then
                diff -u -U3 --color "$tempYamlFile1" "$tempYamlFile2"
            else
                diff -u -U3 "$tempYamlFile1" "$tempYamlFile2"
            fi
            rm "$tempYamlFile1"
            rm "$tempYamlFile2"
        fi
        exit 0
        ;;
    delete)
        nameArg="$( getNthLine "$nonOptArgs" 1 )"
        if [ -z "$nameArg" ]; then
            targetBranch="${configValue_trackers_prefix}${configValue_trackers_name}"
            stateRevision="$targetBranch"
        elif checkStartsWith "$nameArg" '-'; then
            targetBranch="${configValue_trackers_prefix}${configValue_trackers_name}"
            stateRevision="${targetBranch}$( printf '%s\n' "$nameArg" | sed -E 's/^\-/~/' )"
        else
            targetBranch="${configValue_trackers_prefix}${nameArg}"
            stateRevision="$targetBranch"
            offsetArg="$( getNthLine "$nonOptArgs" 2 )"
            if checkStartsWith "$offsetArg" '-'; then
                stateRevision="${stateRevision}$( printf '%s\n' "$offsetArg" | sed -E 's/^\-/~/' )"
            elif [ -n "$offsetArg" ]; then
                printf '%sERROR: %s: %s%s\n' "$formatError" 'Illegal offset argument' "$offsetArg" "$formatErrorEnd" >&2
                exit 1
            fi
        fi
        revPath="${stateRevision}:${STATE_FILE}"
        if ! git show "$revPath" 2>/dev/null > /dev/null; then
            printf '%sERROR: %s: %s%s\n' "$formatError" 'Not a snapshot commit' "$stateRevision" "$formatErrorEnd" >&2
            exit 1
        fi
        parentCommitId="$( git rev-parse --verify "${stateRevision}^" 2>/dev/null )"
        if [ -z "$parentCommitId" ]; then
            printf '%sERROR: %s: %s%s\n' "$formatError" 'Orphan commit deletion is not supported' "$stateRevision" "$formatErrorEnd" >&2
            exit 1
        fi
        commitId="$( git rev-parse "$stateRevision" )"
        logInfoMessage "Delete snapshot at ${stateRevision}, commit id: ${commitId}"
        while IFS=' ' read -r originalCommitId treeId; do
            commitMessage="$( git log -n 1 --format="%B" "$originalCommitId" )"
            currentParentCommitId="$( git rev-parse --verify "${originalCommitId}^" 2>/dev/null )"
            additionalParents="$( git show -s --format=%P "$originalCommitId" | cut -d' ' -f2- )"
            additionalParentArguments="$( printf '%s\n' "$additionalParents" | sed -E 's/\b\w/-p &/g' )"
            newCommitId="$( git commit-tree -p "$parentCommitId" $additionalParentArguments -m "$commitMessage" "$treeId" )"
            logInfoMessage "Replace first-parent of ${originalCommitId} from ${currentParentCommitId} to ${parentCommitId}, resulting commit: ${newCommitId}"
            parentCommitId="${newCommitId}"
        done <<EOF
$( git log "$commitId".."$targetBranch" --first-parent --reverse --format="%H %T" )
EOF
        
        git update-ref refs/heads/"$targetBranch" "$parentCommitId"
        
        printf '%sSUCCESS: %s: %s%s\n' "$formatSuccess" 'Snapshot was successfully deleted' "$commitId" "$formatSuccessEnd"
        
        exit 0
        ;;
    push)
        if ! trackerBranches="$( printTrackerBranchesForSync )"; then
            exit 1
        fi
        
        printf '%s\n' "$trackerBranches" | while IFS= read -r trackerBranch; do
            logInfoMessage "Push tracker branch: ${trackerBranch}"
            setupRemoteNameAndRemoteBranchForSync "$trackerBranch"
            logInfoMessage "Push tracker branch ${trackerBranch} to ${trackerBranch}:${remoteBranch}"
            if ! checkTruthy "$configValue_dryrun"; then
                if ! git push "$remoteName" "${trackerBranch}:${remoteBranch}"; then
                    logWarningMessage "Failed to push tracker branch ${trackerBranch} to ${trackerBranch}:${remoteBranch}"
                    continue
                fi
            fi
        done
        exit 0
        ;;
    pull)
        if ! trackerBranches="$( printTrackerBranchesForSync )"; then
            exit 1
        fi
        
        printf '%s\n' "$trackerBranches" | while IFS= read -r trackerBranch; do
            logInfoMessage "Pull tracker branch: ${trackerBranch}"
            setupRemoteNameAndRemoteBranchForSync "$trackerBranch"
            trackerRemoteBranch="${trackerBranch}/${remoteBranch}"
            logInfoMessage "Fetch tracker remote branch ${trackerRemoteBranch}"
            if ! checkTruthy "$configValue_dryrun"; then
                if ! git push "$remoteName" "${trackerBranch}:${remoteBranch}"; then
                    logWarningMessage "Failed to fetch tracker remote branch ${trackerRemoteBranch}"
                    continue
                fi
            fi
            logInfoMessage "Rebase tracker branch ${trackerBranch} on ${trackerRemoteBranch}"
            if ! checkTruthy "$configValue_dryrun"; then
                if ! git rebase "$trackerBranch" "$trackerRemoteBranch"; then
                    logWarningMessage "Failed to rebase tracker branch ${trackerBranch}"
                    continue
                fi
            fi
        done
        exit 0
        ;;
    *)
        printf '%sERROR: %s%s\n' "$formatError" 'Unknown command' "$formatErrorEnd" >&2
        exit 1
        ;;
esac
