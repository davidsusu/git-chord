#!/bin/sh

VERSION='0.1.0-SNAPSHOT'

COMMANDS="$( printf '%s' '
help # Prints help (also works: (*-h*))
version # Prints version of the chord extension (also works: (*-v*))
config # Prints the current chord configuration (use (*--defaults*) to see the defaults)
snapshot # Creates a snapshot of the repository state
apply # Applies a previously saved snapshot to the repository
show # Shows full data of a previously saved snapshot (or using (*--all*): all chord branches)
push # Pushes the default chord branch (or using (*--all*): all chord branches)
pull # Pulls the default chord branch (or using (*--all*): all chord branches)
' | tail -n +2 )"

DEFAULT_COMMAND='snapshot'

OPTIONS="$( printf '%s' '
trackers.prefix chord/ # Sets the tracker branch prefix
trackers.default main # Sets the default tracker branch name
trackers.remotes.default origin # Sets the default remote name for tracker branches
trackers.remotes.allowautoadd true # Allows automatically adding the default remote if necessary
branches.store.enabled true # Enables saving state of tracked branches
branches.store.regex .* # Sets the regex pattern for saving tracked branches
branches.apply.enabled true # Enables applying the saved state of tracked branches
branches.apply.regex .* # Sets the regex pattern for applying tracked branches
branches.apply.allowremove true # Allows removing branches
branches.apply.allowadd true # Allows adding branches
annotatedtags.store.enabled true # Enables saving state of tracked annotated tags
annotatedtags.store.regex .* # Sets the regex pattern for saving tracked annotated tags
annotatedtags.apply.enabled true # Enables applying the saved state of tracked annotated tags
annotatedtags.apply.regex .* # Sets the regex pattern for applying tracked annotated tags
annotatedtags.apply.allowremove true # Allows removing annotated tags
annotatedtags.apply.allowadd true # Allows adding annotated tags
lightweighttags.store.enabled false # Enables saving state of tracked lightweight tags
lightweighttags.store.regex .* # Sets the regex pattern for saving tracked lightweight tags
lightweighttags.apply.enabled true # Enables applying the saved state of tracked lightweight tags
lightweighttags.apply.regex .* # Sets the regex pattern for applying tracked lightweight tags
lightweighttags.apply.allowremove false # Allows removing lightweight tags
lightweighttags.apply.allowadd false # Allows adding lightweight tags
head.store.enabled true # Enables saving state of the HEAD
head.apply.enabled true # Allows moving the HEAD
stagingarea.store.enabled false # Enables saving state of the staging area
stagingarea.apply.enabled false # Enables applying the saved state of the staging area
stagingarea.apply.allowoverwrite false # Allows overwriting even a dirty staging area
workingtree.store.enabled false # Enables saving the state of the working tree
workingtree.apply.enabled false # Enables applying the saved state of the working tree
workingtree.apply.allowoverwrite false # Allows overwriting even a dirty working tree
dryrun false # Enables dry-run mode, no modification will be applied
verbose false # Enables verbose mode, more information will be printed
color true # Enables color mode, ANSI escapes will be used in the output
defaults false # Enables default mode, the default configuration will be used and printed (forcefully)
all false # Enables the operation for all related objects
' | tail -n +2 )"

checkStartsWith() { # $1: contextString, $2: prefixToCheck
    case "$1" in
        "$2"*) return 0 ;;
        *) return 1 ;;
    esac
}

appendLine() { # $1: array, $2:newLine
    if [ -n "$1" ]; then
        printf '%s\n%s' "$1" "$2"
    else
        printf '%s' "$2"
    fi
}

getNthLine() { # $1: lines, $2 lineNo
    printf '%s\n' "$1" | sed "${2}q;d"
}

repeatChar() { # $1: char, $2: length
    printf "%s%${2}s%s\n" | tr ' ' "$1"
}

normalizeKey() { # $1: rawKey
    printf '%s\n' "$1" | sed -E 's/^\-\-(no\-)?//i' | tr '-' '.' | tr '[:upper:]' '[:lower:]'
}

escapeValue() {
    printf '%s\n' "$1" | sed "s/'/'\\\\''/g"
}

checkBoolValue() { # $1: valueToCheck
    if [ "$1" = 'true' ] || [ "$1" = 'false' ]; then
        return 0
    else 
        return 1
    fi
}

isBoolValue() { # $1: valueToCheck
    if checkBoolValue "$1"; then
        echo '1'
    else 
        echo ''
    fi
}

checkTruthy() { # $1: valueToCheck
    case "$1" in
        true|on|yes|1) return 0 ;;
        *) return 1 ;;
    esac
}

printNlIf() { # $1: isVerbose
    if checkTruthy "$1"; then
        echo ''
    fi
}

getArgumentKey() { # $1: arg
    normalizeKey "$( printf '%s\n' "$1" | cut -d '=' -f 1 | sed -E 's/\-\-(no\-)?//i' )"
}

getArgumentValue() ( # $1: arg, $2: isBool, subshell local: $candidate
    candidate="$( printf '%s\n' "$1" | cut -d '=' -s -f 2- )"
    if [ -z "$candidate" ] && [ -n "$2" ]; then
        if checkStartsWith "$1" '--no-'; then
            echo 'false'
        else
            echo 'true'
        fi
    else
        printf '%s\n' "$candidate"
    fi
)

isArgumentNextExpected() { # $1: arg, $2: isBool
    if [ -n "$2" ]; then
        echo ''
    else
        case "$1" in
            *=*) echo '' ;;
            *) echo '1' ;;
        esac
    fi
}

checkConfigKey() ( # $1: config, $2: key, $3: messagePrefix, subshell local: $line
    while IFS= read -r line; do
        if checkStartsWith "$line" "${2} "; then
            return 0
        fi
    done <<EOF
$( printf '%s\n' "$1" )
EOF
    printf '%sUnrecognized configuration key: %s\n' "$3" "$2" >&2
    return 1
)

getConfigValue() ( # $1: config, $2: key, subshell local: $line
    printf '%s\n' "$1" | while IFS= read -r line; do
        if checkStartsWith "$line" "${2} "; then
            printf '%s\n' "$line" | cut -d ' ' -s -f 2-
            break
        fi
    done
)

setConfigValue() ( # $1: config, $2: key, $3: newValue, subshell local: $found, $line
    found=''
    while IFS= read -r line; do
        if checkStartsWith "$line" "${2} "; then
            printf '%s %s\n' "$2" "$3"
            found='1'
        else
            printf '%s\n' "$line"
        fi
    done <<EOF
$( printf '%s\n' "$1" )
EOF
    if [ -z "$found" ]; then
        printf '%s %s\n' "$2" "$3"
    fi
)

defaults=$( printf '%s' "$OPTIONS" | sed -E 's/ #[^#]*//' )
config="$defaults"

while IFS= read -r line; do
    givenKey="$( printf '%s\n' "$line" | cut -d ' ' -f 1 | sed -E 's/^chord\.//' )"
    if [ -z "$givenKey" ]; then
        continue
    fi
    if checkConfigKey "$defaults" "$givenKey" 'WARNING: '; then
        givenValue="$( printf '%s\n' "$line" | cut -d ' ' -s -f 2- )"
        config="$( setConfigValue "$config" "$givenKey" "$givenValue" )"
    fi
done <<EOF
$( git config --get-regexp 'chord\..*' )
EOF

afterDoubleDash=''
previousKey=''
command=''
nonOptArgs=''
while [ "$#" -gt 0 ]; do
    arg="$1"
    shift
    if [ -n "$previousKey" ]; then
        config="$( setConfigValue "$config" "$previousKey" "$arg" )"
        previousKey=''
        continue
    fi
    if ! checkStartsWith "$arg" '--' || [ -n "$afterDoubleDash" ]; then
        if [ -z "$command" ]; then
            command="$arg"
        else
            nonOptArgs="$( appendLine "$nonOptArgs" "$arg" )"
        fi
        continue
    elif [ "$arg" = '--' ]; then
        afterDoubleDash='1'
        continue
    fi
    argKey="$( getArgumentKey "$arg" )"
    checkConfigKey "$defaults" "$argKey" || exit 1
    argDefaultValue="$( getConfigValue "$defaults" "$argKey" )"
    argIsBool="$( isBoolValue "$argDefaultValue" )"
    argValue="$( getArgumentValue "$arg" "$argIsBool" )"
    argHasNext="$( isArgumentNextExpected "$arg" "$argIsBool" )"
    if [ -n "$argHasNext" ]; then
        previousKey="$argKey"
    else
        config="$( setConfigValue "$config" "$argKey" "$argValue" )"
    fi
done
if [ -n "$previousKey" ]; then
    printf 'No value argument given for configuration key: %s\n' "$previousKey" >&2
    exit 1
fi
if [ -z "$command" ]; then
    command="$DEFAULT_COMMAND"
fi

subcommand="$( getNthLine "$nonOptArgs" 1 )"

while IFS= read -r configLine; do
    configValue="$( printf '%s\n' "$configLine" | cut -d ' ' -f 2- )"
    outVariableName="configValue_$( printf '%s\n' "$configLine" | cut -d ' ' -f 1 | tr '.' '_' )"
    eval "${outVariableName}='$( escapeValue "$configValue")'"
done <<EOF
$( printf '%s\n' "$config" )
EOF

formatError=''
formatWarning=''
formatSuccess=''
formatInfo=''
formatBold=''
formatReset=''
if checkTruthy "$configValue_color"; then
    formatError="$( printf '\e[1;31m' )"
    formatWarning="$( printf '\e[1;33m' )"
    formatSuccess="$( printf '\e[1;32m' )"
    formatInfo="$( printf '\e[1;96m' )"
    formatBold="$( printf '\e[1m' )"
    formatReset="$( printf '\e[0m' )"
fi

if [ "$subcommand" = 'help' ] || [ "$subcommand" = '-h' ]; then
    case "$command" in
        help|-h)
            printf '%s%s%s\n\n' "$formatBold" 'git chord help' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Usage:' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord {-h|help} [<options...>]'
            echo ''
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Description:' "$formatReset"
            printNlIf "$configValue_verbose"
            echo '  Prints information about the available subcommands and options.'
            printNlIf "$configValue_verbose"
            exit 0
            ;;
        version|-v)
            printf '%s%s%s\n\n' "$formatBold" 'git chord version' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Usage:' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord {-v|version} [<options...>]'
            echo ''
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Description:' "$formatReset"
            printNlIf "$configValue_verbose"
            echo '  Prints version of the git chord extension.'
            printNlIf "$configValue_verbose"
            exit 0
            ;;
        config)
            printf '%s%s%s\n\n' "$formatBold" 'git chord config' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Usage:' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord config [list] [<options...>]'
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord config get <key> [<options...>]'
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord config set <key> <value> [<options...>]'
            echo ''
            printf '%s%s%s\n' "$formatBold" 'Example:' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '  %s\n\n' 'git chord config set annotatedtags.store.enabled false'
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Description:' "$formatReset"
            printNlIf "$configValue_verbose"
            echo '  Prints information about the configuration of the git chord extension,'
            echo '  or changes a configuration value for the current git repository.'
            echo ''
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Sub-subcommands:' "$formatReset"
            printNlIf "$configValue_verbose"
            (
                printf '(*list*): This is the default command. '
                printf 'Lists all the available configuration keys and their values. '
                printf 'Using the (*--default*) option you can see the defaults only, '
                printf 'this option works out of git repositories too. '
                printf 'Using the (*--all*) option you can list the ad hoc command line options too. '
            echo '' ) | sed -E "s/\(\*/${formatBold}/g" | sed -E "s/\*\)/${formatReset}/g" | fold -w 80 -s | sed -E 's/^/  /'
            printNlIf "$configValue_verbose"
            (
                printf '(*get*): Gets the value of a given configuration key. '
                printf 'Using the (*--default*) option you can see the default value, '
                printf 'this option works out of git repositories too. '
            echo '' ) | sed -E "s/\(\*/${formatBold}/g" | sed -E "s/\*\)/${formatReset}/g" | fold -w 80 -s | sed -E 's/^/  /'
            printNlIf "$configValue_verbose"
            (
                printf '(*set*): Changes the value of a given configuration key. '
                printf 'You need to specify the key first, then the value. '
                printf 'This sub-subcommand works only inside a git repository, '
                printf 'and will save the value as a repository scoped git config '
                printf 'using the prefix '\''(*chord.*)'\'' in the key. '
            echo '' ) | sed -E "s/\(\*/${formatBold}/g" | sed -E "s/\*\)/${formatReset}/g" | fold -w 80 -s | sed -E 's/^/  /'
            printNlIf "$configValue_verbose"
            exit 0
            ;;
        snapshot)
            printf '%s%s%s\n\n' "$formatBold" 'git chord snapshot' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Usage:' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord snapshot [<name>]'
            printNlIf "$configValue_verbose"
            printf '  %s\n' 'git chord snapshot - <branch>'
            printNlIf "$configValue_verbose"
            echo ''
            printf '%s%s%s\n' "$formatBold" 'Example:' "$formatReset"
            printNlIf "$configValue_verbose"
            printf '  %s\n\n' 'git chord snapshot my-snapshots'
            printNlIf "$configValue_verbose"
            printf '%s%s%s\n' "$formatBold" 'Description:' "$formatReset"
            printNlIf "$configValue_verbose"
            (
                printf 'Creates and saves a snapshot of the entire state of the repository, '
                printf 'based on the configuration. '
                printf 'If you use no parameters, the default tracker branch name will be used with the default prefix. '
                printf 'If you use the (*<name>*) parameter, this branch name will be used with the default prefix. '
                printf 'If you use the '\''(*-*)'\'' parameter, '
                printf 'then the (*<branch>*) parameter will be interpreted as a full branch name. '
                printf 'In any case, the tracker branch will be created if not exist. '
                printf 'All the dependency commits (head of branches, tags, staging area state etc.) '
                printf 'will be stored by their name and full commit hash, '
                printf 'and all such commit hashes will be additional parents of the commit. '
                printf 'The first parent is always the previous commit of the tracker branch, '
                printf 'if there is no such previous commit, then an empty commit will be prepended. '
            echo '' ) | sed -E "s/\(\*/${formatBold}/g" | sed -E "s/\*\)/${formatReset}/g" | fold -w 80 -s | sed -E 's/^/  /'
            printNlIf "$configValue_verbose"
            ;;
        # TODO
        *)
            printf '%s%s: %s%s\n' "$formatError" "ERROR: No help for subcommand" "$subcommand" "$formatReset" >&2
            exit 1
            ;;
    esac
fi

case "$command" in
    help|-h)
        helpTitle='HELP for Git Chord:'
        printf '\n%s%s%s\n' "$formatBold" "$helpTitle" "$formatReset"
        printf '%s\n' "${formatBold}$( repeatChar '=' "$( printf '%s' "$helpTitle" | wc -c )" )${formatReset}"
        printNlIf "$configValue_verbose"
        printf '\n%s%s%s\n' "$formatBold" 'Usage:' "$formatReset"
        printNlIf "$configValue_verbose"
        printf '  %s\n' 'git chord [<subcommand>] [<options...>]'
        if checkTruthy "$configValue_verbose"; then
            printf '\n\n%s%s%s\n\n' "$formatBold" 'Example:' "$formatReset"
            printf '  %s\n' 'git chord snapshot --verbose'
            echo ''
        fi
        printf '\n%s%s%s\n\n' "$formatBold" 'Subcommands:' "$formatReset"
        commandNames="$( printf '%s\n'  "$COMMANDS" | cut -d ' ' -f 1 )"
        commandComments="$( printf '%s\n'  "$COMMANDS" | sed -E 's/^.* # ([^#]*)$/\1/' )"
        commandI=0
        printf '%s\n' "$commandNames" | while IFS= read -r commandName; do
            commandI=$(( commandI + 1 ))
            commandComment="$( getNthLine "$commandComments" "$commandI" | sed -E "s/\(\*/${formatBold}/" | sed -E "s/\*\)/${formatReset}/" )"
            printf '  %s%s%s\n' "$formatBold" "$commandName" "$formatReset"
            printf '    %s\n' "$commandComment"
            printNlIf "$configValue_verbose"
        done
        printf '\n%s%s%s\n\n' "$formatBold" 'Options:' "$formatReset"
        configKeys="$( printf '%s\n'  "$defaults" | cut -d ' ' -f 1 )"
        defaultValues="$( printf '%s\n'  "$defaults" | cut -d ' ' -f 2- )"
        configComments="$( printf '%s\n'  "$OPTIONS" | sed -E 's/^.* # ([^#]*)$/\1/' )"
        configI=0
        printf '%s\n' "$configKeys" | while IFS= read -r configKey; do
            configI="$(( configI + 1 ))"
            defaultValue="$( printf '%s\n'  "$defaultValues" | sed "${configI}q;d" )"
            configComment="$( printf '%s\n'  "$configComments" | sed "${configI}q;d" )"
            optionPrefix='--'
            if checkBoolValue "$defaultValue"; then
                optionPrefix='--[no-]'
                configComment="$( printf '%s\n' "$configComment" | sed -E 's/ /\/disables /' )"
            fi
            optionName="${optionPrefix}$( printf '%s\n' "$configKey" | tr '.' '-' )"
            
            if checkTruthy "$configValue_verbose"; then
                printf '  %s%-41s%s%sBuilt-in default: %s%s\n      %s\n\n' \
                    "$formatBold" "$optionName" "$formatReset" "$formatInfo" "$defaultValue" "$formatReset" "$configComment"
            else
                printf '  %s%-41s%s\n      %s\n' \
                    "$formatBold" "$optionName" "$formatReset" "$configComment"
            fi
        done
        printf '\n%s%s%s\n\n' "$formatBold" 'Exit statuses:' "$formatReset"
        printf '  %s0%s - in case of success\n' "$formatBold" "$formatReset"
        printf '  %s1%s - in case of error\n' "$formatBold" "$formatReset"
        printf '  %s2%s - if the action was aborted due to dryrun mode\n' "$formatBold" "$formatReset"
        printNlIf "$configValue_verbose"
        exit 0
        ;;
    version|-v)
        if checkTruthy "$configValue_verbose"; then
            git --version
            printf 'chord version %s\n' "$VERSION"
        else
            printf '%s\n' "$VERSION"
        fi
        exit 0
        ;;
    config)
            if checkTruthy "$configValue_defaults"; then
                if [ -z "$subcommand" ] || [ "$subcommand" = 'list' ]; then
                    filteredDefaults="$defaults"
                    if ! checkTruthy "$configValue_all"; then
                        filteredDefaults="$( printf '%s\n' "$defaults" | grep -F '.' )"
                    fi
                    if checkTruthy "$configValue_verbose"; then
                        printf '%s%-40s%s%s\n' "$formatBold" 'Key:' 'Default:' "$formatReset"
                        printf '%s%s %s%s\n' "$formatBold" "$( repeatChar '=' 39 )" "$( repeatChar '=' 15 )" "$formatReset"
                        echo ''
                        printf '%s\n' "$filteredDefaults" | while IFS= read -r line; do
                            configKey="$( printf '%s\n' "$line" | cut -d ' ' -f 1 )"
                            configDefaultValue="$( printf '%s\n' "$line" | cut -d ' ' -f 2- )"
                            printf '%-40s%s\n' "$configKey" "$configDefaultValue"
                        done
                    else
                        printf '%s\n' "$filteredDefaults"
                    fi
                    exit 0
                elif [ "$subcommand" = 'get' ]; then
                    configKey="$( getNthLine "$nonOptArgs" 2 )"
                    configDefaultValue="$( getConfigValue "$defaults" "$configKey" )"
                    if checkTruthy "$configValue_verbose"; then
                        printf 'Key:     %s%s%s\n' "$formatBold" "$configKey" "$formatReset"
                        printf 'Default: %s%s%s\n' "$formatBold" "$configDefaultValue" "$formatReset"
                    else
                        printf '%s\n' "$configDefaultValue"
                    fi
                    exit 0
                elif [ "$subcommand" = 'set' ]; then
                    printf '%sERROR: Default value can not be changed%s\n' "$formatError" "$formatReset" >&2
                    exit 1
                fi
            fi
        ;;
esac

if ! git rev-parse --git-dir > /dev/null 2>&1; then
    printf '%sERROR: Not a git repository%s\n' "$formatError" "$formatReset" >&2
    exit 1
fi

case "$command" in
    config)
        if [ -z "$subcommand" ] || [ "$subcommand" = 'list' ]; then
            filteredConfig="$config"
            if ! checkTruthy "$configValue_all"; then
                filteredConfig="$( printf '%s\n' "$config" | grep -F '.' )"
            fi
            if checkTruthy "$configValue_verbose"; then
                printf '%s%-40s%-15s%s%s\n' "$formatBold" 'Key:' 'Default:' 'Value:' "$formatReset"
                printf '%s%s %s %s%s\n' "$formatBold" "$( repeatChar '=' 39 )" "$( repeatChar '=' 14 )" "$( repeatChar '=' 20 )" "$formatReset"
                echo ''
                printf '%s\n' "$filteredConfig" | while IFS= read -r line; do
                    configKey="$( printf '%s\n' "$line" | cut -d ' ' -f 1 )"
                    configValue="$( printf '%s\n' "$line" | cut -d ' ' -f 2- )"
                    configDefaultValue="$( getConfigValue "$defaults" "$configKey" )"
                    printf '%-40s%-15s%s\n' "$configKey" "$configDefaultValue" "$configValue"
                done
            else
                printf '%s\n' "$filteredConfig"
            fi
        elif [ "$subcommand" = 'get' ]; then
            configKey="$( getNthLine "$nonOptArgs" 2 )"
            configDefaultValue="$( getConfigValue "$defaults" "$configKey" )"
            configValue="$( getConfigValue "$config" "$configKey" )"
            if checkTruthy "$configValue_verbose"; then
                printf 'Key:     %s%s%s\n' "$formatBold" "$configKey" "$formatReset"
                printf 'Default: %s%s%s\n' "$formatBold" "$configDefaultValue" "$formatReset"
                printf 'Value:   %s%s%s\n' "$formatBold" "$configValue" "$formatReset"
            else
                printf '%s\n' "$configValue"
            fi
        elif [ "$subcommand" = 'set' ]; then
            configKey="$( getNthLine "$nonOptArgs" 2 )"
            configNewValue="$( getNthLine "$nonOptArgs" 3 )"
            if checkTruthy "$configValue_verbose"; then
                configOldValue="$( getConfigValue "$config" )"
                printf 'Set %s%s%s from '%s%s%s' to '%s%s%s'\n' \
                    "$formatBold" "$configKey" "$formatReset" \
                    "$formatBold" "$configOldValue" "$formatReset" \
                    "$formatBold" "$configNewValue" "$formatReset"
            fi
            if checkTruthy "$configValue_dryrun"; then
                exit 2
            fi
            if ! git config "chord.${configKey}" "$configNewValue"; then
                printf '%sERROR: Failed to set value%s\n' "$formatError" "$formatReset" >&2
                exit 1
            fi
        else
            printf '%sERROR: Unknown subcommand of config: %s%s\n' "$formatError" "$subcommand" "$formatReset" >&2
            exit 1
        fi
        exit 0
        ;;
    snapshot)
        
        # TODO
        #trackers.prefix chord/ # Sets the tracker branch prefix
        #trackers.default main # Sets the tracker branch name
        #branches.store.enabled true # Enables saving state of tracked branches
        #branches.store.regex .* # Sets the regex pattern for saving tracked branches
        #annotatedtags.store.enabled true # Enables saving state of tracked annotated tags
        #annotatedtags.store.regex .* # Sets the regex pattern for saving tracked annotated tags
        #lightweighttags.store.enabled false # Enables saving state of tracked lightweight tags
        #lightweighttags.store.regex .* # Sets the regex pattern for saving tracked lightweight tags
        #head.store.enabled true # Enables saving state of the HEAD
        #stagingarea.store.enabled false # Enables saving state of the staging area
        #workingtree.store.enabled false # Enables saving the state of the working tree

        exit 0
        ;;
esac

# TODO
echo "COMMAND: $command"
echo ""
echo "Non-opt args:"
echo "============="
echo "$nonOptArgs"
echo ""
echo "Effective config:"
echo "================="
echo "$config"


